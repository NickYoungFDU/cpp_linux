/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "cpp_linux_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace azure { namespace storage { namespace cpp_linux {

int _kMatchInformationValues[] = {
  MatchInformation::OnlyOnServer,
  MatchInformation::OnlyInKeys,
  MatchInformation::DeletedOnClient,
  MatchInformation::Match
};
const char* _kMatchInformationNames[] = {
  "OnlyOnServer",
  "OnlyInKeys",
  "DeletedOnClient",
  "Match"
};
const std::map<int, const char*> _MatchInformation_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kMatchInformationValues, _kMatchInformationNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kLinuxFileModeValues[] = {
  LinuxFileMode::Append,
  LinuxFileMode::Create,
  LinuxFileMode::CreateNew,
  LinuxFileMode::Open,
  LinuxFileMode::OpenOrCreate,
  LinuxFileMode::Truncate
};
const char* _kLinuxFileModeNames[] = {
  "Append",
  "Create",
  "CreateNew",
  "Open",
  "OpenOrCreate",
  "Truncate"
};
const std::map<int, const char*> _LinuxFileMode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kLinuxFileModeValues, _kLinuxFileModeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kLinuxFileAccessValues[] = {
  LinuxFileAccess::Read,
  LinuxFileAccess::Write,
  LinuxFileAccess::ReadWrite
};
const char* _kLinuxFileAccessNames[] = {
  "Read",
  "Write",
  "ReadWrite"
};
const std::map<int, const char*> _LinuxFileAccess_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kLinuxFileAccessValues, _kLinuxFileAccessNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kOperationTypeValues[] = {
  OperationType::MapFileShare,
  OperationType::UnmapFileShare,
  OperationType::CreateDirectory,
  OperationType::DeleteDirectory,
  OperationType::CreateFile,
  OperationType::DeleteFile,
  OperationType::ReadFile,
  OperationType::WriteFile,
  OperationType::ListFile,
  OperationType::GetFileLength,
  OperationType::SetFileLength
};
const char* _kOperationTypeNames[] = {
  "MapFileShare",
  "UnmapFileShare",
  "CreateDirectory",
  "DeleteDirectory",
  "CreateFile",
  "DeleteFile",
  "ReadFile",
  "WriteFile",
  "ListFile",
  "GetFileLength",
  "SetFileLength"
};
const std::map<int, const char*> _OperationType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(11, _kOperationTypeValues, _kOperationTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


LinuxFileException::~LinuxFileException() throw() {
}


void LinuxFileException::__set_ErrorMessage(const std::string& val) {
  this->ErrorMessage = val;
}

void LinuxFileException::__set_Type(const OperationType::type val) {
  this->Type = val;
}

void LinuxFileException::__set_AdditionalInfo(const std::map<std::string, std::string> & val) {
  this->AdditionalInfo = val;
__isset.AdditionalInfo = true;
}

const char* LinuxFileException::ascii_fingerprint = "BDDAF3D09FC0B99327A424F4DD1D4E7A";
const uint8_t LinuxFileException::binary_fingerprint[16] = {0xBD,0xDA,0xF3,0xD0,0x9F,0xC0,0xB9,0x93,0x27,0xA4,0x24,0xF4,0xDD,0x1D,0x4E,0x7A};

uint32_t LinuxFileException::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ErrorMessage = false;
  bool isset_Type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ErrorMessage);
          isset_ErrorMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->Type = (OperationType::type)ecast0;
          isset_Type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->AdditionalInfo.clear();
            uint32_t _size1;
            ::apache::thrift::protocol::TType _ktype2;
            ::apache::thrift::protocol::TType _vtype3;
            xfer += iprot->readMapBegin(_ktype2, _vtype3, _size1);
            uint32_t _i5;
            for (_i5 = 0; _i5 < _size1; ++_i5)
            {
              std::string _key6;
              xfer += iprot->readString(_key6);
              std::string& _val7 = this->AdditionalInfo[_key6];
              xfer += iprot->readString(_val7);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.AdditionalInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ErrorMessage)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LinuxFileException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("LinuxFileException");

  xfer += oprot->writeFieldBegin("ErrorMessage", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->ErrorMessage);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->Type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.AdditionalInfo) {
    xfer += oprot->writeFieldBegin("AdditionalInfo", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->AdditionalInfo.size()));
      std::map<std::string, std::string> ::const_iterator _iter8;
      for (_iter8 = this->AdditionalInfo.begin(); _iter8 != this->AdditionalInfo.end(); ++_iter8)
      {
        xfer += oprot->writeString(_iter8->first);
        xfer += oprot->writeString(_iter8->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(LinuxFileException &a, LinuxFileException &b) {
  using ::std::swap;
  swap(a.ErrorMessage, b.ErrorMessage);
  swap(a.Type, b.Type);
  swap(a.AdditionalInfo, b.AdditionalInfo);
  swap(a.__isset, b.__isset);
}

LinuxFileException::LinuxFileException(const LinuxFileException& other9) : TException() {
  ErrorMessage = other9.ErrorMessage;
  Type = other9.Type;
  AdditionalInfo = other9.AdditionalInfo;
  __isset = other9.__isset;
}
LinuxFileException& LinuxFileException::operator=(const LinuxFileException& other10) {
  ErrorMessage = other10.ErrorMessage;
  Type = other10.Type;
  AdditionalInfo = other10.AdditionalInfo;
  __isset = other10.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const LinuxFileException& obj) {
  using apache::thrift::to_string;
  out << "LinuxFileException(";
  out << "ErrorMessage=" << to_string(obj.ErrorMessage);
  out << ", " << "Type=" << to_string(obj.Type);
  out << ", " << "AdditionalInfo="; (obj.__isset.AdditionalInfo ? (out << to_string(obj.AdditionalInfo)) : (out << "<null>"));
  out << ")";
  return out;
}


LinuxFileResponse::~LinuxFileResponse() throw() {
}


void LinuxFileResponse::__set_Success(const bool val) {
  this->Success = val;
}

void LinuxFileResponse::__set_ResponseMessage(const std::string& val) {
  this->ResponseMessage = val;
}

void LinuxFileResponse::__set_Type(const OperationType::type val) {
  this->Type = val;
}

void LinuxFileResponse::__set_AdditionalInfo(const std::map<std::string, std::string> & val) {
  this->AdditionalInfo = val;
__isset.AdditionalInfo = true;
}

void LinuxFileResponse::__set_Buffer(const std::string& val) {
  this->Buffer = val;
__isset.Buffer = true;
}

const char* LinuxFileResponse::ascii_fingerprint = "1078773DA8EE999B3618DACAB4C9A10B";
const uint8_t LinuxFileResponse::binary_fingerprint[16] = {0x10,0x78,0x77,0x3D,0xA8,0xEE,0x99,0x9B,0x36,0x18,0xDA,0xCA,0xB4,0xC9,0xA1,0x0B};

uint32_t LinuxFileResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Success = false;
  bool isset_ResponseMessage = false;
  bool isset_Type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->Success);
          isset_Success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ResponseMessage);
          isset_ResponseMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast11;
          xfer += iprot->readI32(ecast11);
          this->Type = (OperationType::type)ecast11;
          isset_Type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->AdditionalInfo.clear();
            uint32_t _size12;
            ::apache::thrift::protocol::TType _ktype13;
            ::apache::thrift::protocol::TType _vtype14;
            xfer += iprot->readMapBegin(_ktype13, _vtype14, _size12);
            uint32_t _i16;
            for (_i16 = 0; _i16 < _size12; ++_i16)
            {
              std::string _key17;
              xfer += iprot->readString(_key17);
              std::string& _val18 = this->AdditionalInfo[_key17];
              xfer += iprot->readString(_val18);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.AdditionalInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->Buffer);
          this->__isset.Buffer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Success)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_ResponseMessage)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LinuxFileResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("LinuxFileResponse");

  xfer += oprot->writeFieldBegin("Success", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->Success);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ResponseMessage", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->ResponseMessage);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Type", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->Type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.AdditionalInfo) {
    xfer += oprot->writeFieldBegin("AdditionalInfo", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->AdditionalInfo.size()));
      std::map<std::string, std::string> ::const_iterator _iter19;
      for (_iter19 = this->AdditionalInfo.begin(); _iter19 != this->AdditionalInfo.end(); ++_iter19)
      {
        xfer += oprot->writeString(_iter19->first);
        xfer += oprot->writeString(_iter19->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Buffer) {
    xfer += oprot->writeFieldBegin("Buffer", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->Buffer);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(LinuxFileResponse &a, LinuxFileResponse &b) {
  using ::std::swap;
  swap(a.Success, b.Success);
  swap(a.ResponseMessage, b.ResponseMessage);
  swap(a.Type, b.Type);
  swap(a.AdditionalInfo, b.AdditionalInfo);
  swap(a.Buffer, b.Buffer);
  swap(a.__isset, b.__isset);
}

LinuxFileResponse::LinuxFileResponse(const LinuxFileResponse& other20) {
  Success = other20.Success;
  ResponseMessage = other20.ResponseMessage;
  Type = other20.Type;
  AdditionalInfo = other20.AdditionalInfo;
  Buffer = other20.Buffer;
  __isset = other20.__isset;
}
LinuxFileResponse& LinuxFileResponse::operator=(const LinuxFileResponse& other21) {
  Success = other21.Success;
  ResponseMessage = other21.ResponseMessage;
  Type = other21.Type;
  AdditionalInfo = other21.AdditionalInfo;
  Buffer = other21.Buffer;
  __isset = other21.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const LinuxFileResponse& obj) {
  using apache::thrift::to_string;
  out << "LinuxFileResponse(";
  out << "Success=" << to_string(obj.Success);
  out << ", " << "ResponseMessage=" << to_string(obj.ResponseMessage);
  out << ", " << "Type=" << to_string(obj.Type);
  out << ", " << "AdditionalInfo="; (obj.__isset.AdditionalInfo ? (out << to_string(obj.AdditionalInfo)) : (out << "<null>"));
  out << ", " << "Buffer="; (obj.__isset.Buffer ? (out << to_string(obj.Buffer)) : (out << "<null>"));
  out << ")";
  return out;
}

}}} // namespace
