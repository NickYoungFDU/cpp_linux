/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef XSMBService_H
#define XSMBService_H

#include <thrift/TDispatchProcessor.h>
#include "cpp_linux_types.h"

namespace azure { namespace storage { namespace cpp_linux {

class XSMBServiceIf {
 public:
  virtual ~XSMBServiceIf() {}
  virtual void CreateDirectory(LinuxFileResponse& _return, const std::string& dirPath) = 0;
  virtual void DeleteDirectory(LinuxFileResponse& _return, const std::string& dirPath, const bool isRecursive) = 0;
  virtual void CreateFile(LinuxFileResponse& _return, const std::string& filePath, const int64_t fileSize, const bool noBuffering) = 0;
  virtual void DeleteFile(LinuxFileResponse& _return, const std::string& filePath) = 0;
  virtual void ReadFile(LinuxFileResponse& _return, const std::string& filePath, const StreamDataLayout& data, const bool noBuffering, const int8_t fileVersion, const bool useVersionInData, const std::string& keyName) = 0;
  virtual void WriteFile(LinuxFileResponse& _return, const std::string& filePath, const StreamDataLayout& data, const bool noBuffering, const int8_t fileVersion, const bool useVersionInData, const std::string& keyName) = 0;
  virtual void ListCloudFiles(LinuxFileResponse& _return, const std::string& dirPath, const bool isRecursive, const std::map<std::string, MatchInformation::type> & files, const std::map<std::string, MatchInformation::type> & dirs) = 0;
  virtual int64_t GetCloudFileLength(const std::string& filePath) = 0;
  virtual void SetCloudFileLength(LinuxFileResponse& _return, const std::string& filePath, const int64_t fileLength) = 0;
};

class XSMBServiceIfFactory {
 public:
  typedef XSMBServiceIf Handler;

  virtual ~XSMBServiceIfFactory() {}

  virtual XSMBServiceIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(XSMBServiceIf* /* handler */) = 0;
};

class XSMBServiceIfSingletonFactory : virtual public XSMBServiceIfFactory {
 public:
  XSMBServiceIfSingletonFactory(const boost::shared_ptr<XSMBServiceIf>& iface) : iface_(iface) {}
  virtual ~XSMBServiceIfSingletonFactory() {}

  virtual XSMBServiceIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(XSMBServiceIf* /* handler */) {}

 protected:
  boost::shared_ptr<XSMBServiceIf> iface_;
};

class XSMBServiceNull : virtual public XSMBServiceIf {
 public:
  virtual ~XSMBServiceNull() {}
  void CreateDirectory(LinuxFileResponse& /* _return */, const std::string& /* dirPath */) {
    return;
  }
  void DeleteDirectory(LinuxFileResponse& /* _return */, const std::string& /* dirPath */, const bool /* isRecursive */) {
    return;
  }
  void CreateFile(LinuxFileResponse& /* _return */, const std::string& /* filePath */, const int64_t /* fileSize */, const bool /* noBuffering */) {
    return;
  }
  void DeleteFile(LinuxFileResponse& /* _return */, const std::string& /* filePath */) {
    return;
  }
  void ReadFile(LinuxFileResponse& /* _return */, const std::string& /* filePath */, const StreamDataLayout& /* data */, const bool /* noBuffering */, const int8_t /* fileVersion */, const bool /* useVersionInData */, const std::string& /* keyName */) {
    return;
  }
  void WriteFile(LinuxFileResponse& /* _return */, const std::string& /* filePath */, const StreamDataLayout& /* data */, const bool /* noBuffering */, const int8_t /* fileVersion */, const bool /* useVersionInData */, const std::string& /* keyName */) {
    return;
  }
  void ListCloudFiles(LinuxFileResponse& /* _return */, const std::string& /* dirPath */, const bool /* isRecursive */, const std::map<std::string, MatchInformation::type> & /* files */, const std::map<std::string, MatchInformation::type> & /* dirs */) {
    return;
  }
  int64_t GetCloudFileLength(const std::string& /* filePath */) {
    int64_t _return = 0;
    return _return;
  }
  void SetCloudFileLength(LinuxFileResponse& /* _return */, const std::string& /* filePath */, const int64_t /* fileLength */) {
    return;
  }
};

typedef struct _XSMBService_CreateDirectory_args__isset {
  _XSMBService_CreateDirectory_args__isset() : dirPath(false) {}
  bool dirPath :1;
} _XSMBService_CreateDirectory_args__isset;

class XSMBService_CreateDirectory_args {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  XSMBService_CreateDirectory_args(const XSMBService_CreateDirectory_args&);
  XSMBService_CreateDirectory_args& operator=(const XSMBService_CreateDirectory_args&);
  XSMBService_CreateDirectory_args() : dirPath() {
  }

  virtual ~XSMBService_CreateDirectory_args() throw();
  std::string dirPath;

  _XSMBService_CreateDirectory_args__isset __isset;

  void __set_dirPath(const std::string& val);

  bool operator == (const XSMBService_CreateDirectory_args & rhs) const
  {
    if (!(dirPath == rhs.dirPath))
      return false;
    return true;
  }
  bool operator != (const XSMBService_CreateDirectory_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_CreateDirectory_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_CreateDirectory_args& obj);
};


class XSMBService_CreateDirectory_pargs {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};


  virtual ~XSMBService_CreateDirectory_pargs() throw();
  const std::string* dirPath;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_CreateDirectory_pargs& obj);
};

typedef struct _XSMBService_CreateDirectory_result__isset {
  _XSMBService_CreateDirectory_result__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_CreateDirectory_result__isset;

class XSMBService_CreateDirectory_result {
 public:

  static const char* ascii_fingerprint; // = "ACEF167A387B2A5EA3E03B91E107CA4D";
  static const uint8_t binary_fingerprint[16]; // = {0xAC,0xEF,0x16,0x7A,0x38,0x7B,0x2A,0x5E,0xA3,0xE0,0x3B,0x91,0xE1,0x07,0xCA,0x4D};

  XSMBService_CreateDirectory_result(const XSMBService_CreateDirectory_result&);
  XSMBService_CreateDirectory_result& operator=(const XSMBService_CreateDirectory_result&);
  XSMBService_CreateDirectory_result() {
  }

  virtual ~XSMBService_CreateDirectory_result() throw();
  LinuxFileResponse success;
  LinuxFileException linuxFileException;

  _XSMBService_CreateDirectory_result__isset __isset;

  void __set_success(const LinuxFileResponse& val);

  void __set_linuxFileException(const LinuxFileException& val);

  bool operator == (const XSMBService_CreateDirectory_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(linuxFileException == rhs.linuxFileException))
      return false;
    return true;
  }
  bool operator != (const XSMBService_CreateDirectory_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_CreateDirectory_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_CreateDirectory_result& obj);
};

typedef struct _XSMBService_CreateDirectory_presult__isset {
  _XSMBService_CreateDirectory_presult__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_CreateDirectory_presult__isset;

class XSMBService_CreateDirectory_presult {
 public:

  static const char* ascii_fingerprint; // = "ACEF167A387B2A5EA3E03B91E107CA4D";
  static const uint8_t binary_fingerprint[16]; // = {0xAC,0xEF,0x16,0x7A,0x38,0x7B,0x2A,0x5E,0xA3,0xE0,0x3B,0x91,0xE1,0x07,0xCA,0x4D};


  virtual ~XSMBService_CreateDirectory_presult() throw();
  LinuxFileResponse* success;
  LinuxFileException linuxFileException;

  _XSMBService_CreateDirectory_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_CreateDirectory_presult& obj);
};

typedef struct _XSMBService_DeleteDirectory_args__isset {
  _XSMBService_DeleteDirectory_args__isset() : dirPath(false), isRecursive(false) {}
  bool dirPath :1;
  bool isRecursive :1;
} _XSMBService_DeleteDirectory_args__isset;

class XSMBService_DeleteDirectory_args {
 public:

  static const char* ascii_fingerprint; // = "7D61C9AA00102AB4D8F72A1DA58297DC";
  static const uint8_t binary_fingerprint[16]; // = {0x7D,0x61,0xC9,0xAA,0x00,0x10,0x2A,0xB4,0xD8,0xF7,0x2A,0x1D,0xA5,0x82,0x97,0xDC};

  XSMBService_DeleteDirectory_args(const XSMBService_DeleteDirectory_args&);
  XSMBService_DeleteDirectory_args& operator=(const XSMBService_DeleteDirectory_args&);
  XSMBService_DeleteDirectory_args() : dirPath(), isRecursive(0) {
  }

  virtual ~XSMBService_DeleteDirectory_args() throw();
  std::string dirPath;
  bool isRecursive;

  _XSMBService_DeleteDirectory_args__isset __isset;

  void __set_dirPath(const std::string& val);

  void __set_isRecursive(const bool val);

  bool operator == (const XSMBService_DeleteDirectory_args & rhs) const
  {
    if (!(dirPath == rhs.dirPath))
      return false;
    if (!(isRecursive == rhs.isRecursive))
      return false;
    return true;
  }
  bool operator != (const XSMBService_DeleteDirectory_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_DeleteDirectory_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_DeleteDirectory_args& obj);
};


class XSMBService_DeleteDirectory_pargs {
 public:

  static const char* ascii_fingerprint; // = "7D61C9AA00102AB4D8F72A1DA58297DC";
  static const uint8_t binary_fingerprint[16]; // = {0x7D,0x61,0xC9,0xAA,0x00,0x10,0x2A,0xB4,0xD8,0xF7,0x2A,0x1D,0xA5,0x82,0x97,0xDC};


  virtual ~XSMBService_DeleteDirectory_pargs() throw();
  const std::string* dirPath;
  const bool* isRecursive;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_DeleteDirectory_pargs& obj);
};

typedef struct _XSMBService_DeleteDirectory_result__isset {
  _XSMBService_DeleteDirectory_result__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_DeleteDirectory_result__isset;

class XSMBService_DeleteDirectory_result {
 public:

  static const char* ascii_fingerprint; // = "ACEF167A387B2A5EA3E03B91E107CA4D";
  static const uint8_t binary_fingerprint[16]; // = {0xAC,0xEF,0x16,0x7A,0x38,0x7B,0x2A,0x5E,0xA3,0xE0,0x3B,0x91,0xE1,0x07,0xCA,0x4D};

  XSMBService_DeleteDirectory_result(const XSMBService_DeleteDirectory_result&);
  XSMBService_DeleteDirectory_result& operator=(const XSMBService_DeleteDirectory_result&);
  XSMBService_DeleteDirectory_result() {
  }

  virtual ~XSMBService_DeleteDirectory_result() throw();
  LinuxFileResponse success;
  LinuxFileException linuxFileException;

  _XSMBService_DeleteDirectory_result__isset __isset;

  void __set_success(const LinuxFileResponse& val);

  void __set_linuxFileException(const LinuxFileException& val);

  bool operator == (const XSMBService_DeleteDirectory_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(linuxFileException == rhs.linuxFileException))
      return false;
    return true;
  }
  bool operator != (const XSMBService_DeleteDirectory_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_DeleteDirectory_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_DeleteDirectory_result& obj);
};

typedef struct _XSMBService_DeleteDirectory_presult__isset {
  _XSMBService_DeleteDirectory_presult__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_DeleteDirectory_presult__isset;

class XSMBService_DeleteDirectory_presult {
 public:

  static const char* ascii_fingerprint; // = "ACEF167A387B2A5EA3E03B91E107CA4D";
  static const uint8_t binary_fingerprint[16]; // = {0xAC,0xEF,0x16,0x7A,0x38,0x7B,0x2A,0x5E,0xA3,0xE0,0x3B,0x91,0xE1,0x07,0xCA,0x4D};


  virtual ~XSMBService_DeleteDirectory_presult() throw();
  LinuxFileResponse* success;
  LinuxFileException linuxFileException;

  _XSMBService_DeleteDirectory_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_DeleteDirectory_presult& obj);
};

typedef struct _XSMBService_CreateFile_args__isset {
  _XSMBService_CreateFile_args__isset() : filePath(false), fileSize(false), noBuffering(false) {}
  bool filePath :1;
  bool fileSize :1;
  bool noBuffering :1;
} _XSMBService_CreateFile_args__isset;

class XSMBService_CreateFile_args {
 public:

  static const char* ascii_fingerprint; // = "B47B7A9B23016536A84872EAB968623F";
  static const uint8_t binary_fingerprint[16]; // = {0xB4,0x7B,0x7A,0x9B,0x23,0x01,0x65,0x36,0xA8,0x48,0x72,0xEA,0xB9,0x68,0x62,0x3F};

  XSMBService_CreateFile_args(const XSMBService_CreateFile_args&);
  XSMBService_CreateFile_args& operator=(const XSMBService_CreateFile_args&);
  XSMBService_CreateFile_args() : filePath(), fileSize(0), noBuffering(0) {
  }

  virtual ~XSMBService_CreateFile_args() throw();
  std::string filePath;
  int64_t fileSize;
  bool noBuffering;

  _XSMBService_CreateFile_args__isset __isset;

  void __set_filePath(const std::string& val);

  void __set_fileSize(const int64_t val);

  void __set_noBuffering(const bool val);

  bool operator == (const XSMBService_CreateFile_args & rhs) const
  {
    if (!(filePath == rhs.filePath))
      return false;
    if (!(fileSize == rhs.fileSize))
      return false;
    if (!(noBuffering == rhs.noBuffering))
      return false;
    return true;
  }
  bool operator != (const XSMBService_CreateFile_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_CreateFile_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_CreateFile_args& obj);
};


class XSMBService_CreateFile_pargs {
 public:

  static const char* ascii_fingerprint; // = "B47B7A9B23016536A84872EAB968623F";
  static const uint8_t binary_fingerprint[16]; // = {0xB4,0x7B,0x7A,0x9B,0x23,0x01,0x65,0x36,0xA8,0x48,0x72,0xEA,0xB9,0x68,0x62,0x3F};


  virtual ~XSMBService_CreateFile_pargs() throw();
  const std::string* filePath;
  const int64_t* fileSize;
  const bool* noBuffering;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_CreateFile_pargs& obj);
};

typedef struct _XSMBService_CreateFile_result__isset {
  _XSMBService_CreateFile_result__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_CreateFile_result__isset;

class XSMBService_CreateFile_result {
 public:

  static const char* ascii_fingerprint; // = "ACEF167A387B2A5EA3E03B91E107CA4D";
  static const uint8_t binary_fingerprint[16]; // = {0xAC,0xEF,0x16,0x7A,0x38,0x7B,0x2A,0x5E,0xA3,0xE0,0x3B,0x91,0xE1,0x07,0xCA,0x4D};

  XSMBService_CreateFile_result(const XSMBService_CreateFile_result&);
  XSMBService_CreateFile_result& operator=(const XSMBService_CreateFile_result&);
  XSMBService_CreateFile_result() {
  }

  virtual ~XSMBService_CreateFile_result() throw();
  LinuxFileResponse success;
  LinuxFileException linuxFileException;

  _XSMBService_CreateFile_result__isset __isset;

  void __set_success(const LinuxFileResponse& val);

  void __set_linuxFileException(const LinuxFileException& val);

  bool operator == (const XSMBService_CreateFile_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(linuxFileException == rhs.linuxFileException))
      return false;
    return true;
  }
  bool operator != (const XSMBService_CreateFile_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_CreateFile_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_CreateFile_result& obj);
};

typedef struct _XSMBService_CreateFile_presult__isset {
  _XSMBService_CreateFile_presult__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_CreateFile_presult__isset;

class XSMBService_CreateFile_presult {
 public:

  static const char* ascii_fingerprint; // = "ACEF167A387B2A5EA3E03B91E107CA4D";
  static const uint8_t binary_fingerprint[16]; // = {0xAC,0xEF,0x16,0x7A,0x38,0x7B,0x2A,0x5E,0xA3,0xE0,0x3B,0x91,0xE1,0x07,0xCA,0x4D};


  virtual ~XSMBService_CreateFile_presult() throw();
  LinuxFileResponse* success;
  LinuxFileException linuxFileException;

  _XSMBService_CreateFile_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_CreateFile_presult& obj);
};

typedef struct _XSMBService_DeleteFile_args__isset {
  _XSMBService_DeleteFile_args__isset() : filePath(false) {}
  bool filePath :1;
} _XSMBService_DeleteFile_args__isset;

class XSMBService_DeleteFile_args {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  XSMBService_DeleteFile_args(const XSMBService_DeleteFile_args&);
  XSMBService_DeleteFile_args& operator=(const XSMBService_DeleteFile_args&);
  XSMBService_DeleteFile_args() : filePath() {
  }

  virtual ~XSMBService_DeleteFile_args() throw();
  std::string filePath;

  _XSMBService_DeleteFile_args__isset __isset;

  void __set_filePath(const std::string& val);

  bool operator == (const XSMBService_DeleteFile_args & rhs) const
  {
    if (!(filePath == rhs.filePath))
      return false;
    return true;
  }
  bool operator != (const XSMBService_DeleteFile_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_DeleteFile_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_DeleteFile_args& obj);
};


class XSMBService_DeleteFile_pargs {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};


  virtual ~XSMBService_DeleteFile_pargs() throw();
  const std::string* filePath;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_DeleteFile_pargs& obj);
};

typedef struct _XSMBService_DeleteFile_result__isset {
  _XSMBService_DeleteFile_result__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_DeleteFile_result__isset;

class XSMBService_DeleteFile_result {
 public:

  static const char* ascii_fingerprint; // = "ACEF167A387B2A5EA3E03B91E107CA4D";
  static const uint8_t binary_fingerprint[16]; // = {0xAC,0xEF,0x16,0x7A,0x38,0x7B,0x2A,0x5E,0xA3,0xE0,0x3B,0x91,0xE1,0x07,0xCA,0x4D};

  XSMBService_DeleteFile_result(const XSMBService_DeleteFile_result&);
  XSMBService_DeleteFile_result& operator=(const XSMBService_DeleteFile_result&);
  XSMBService_DeleteFile_result() {
  }

  virtual ~XSMBService_DeleteFile_result() throw();
  LinuxFileResponse success;
  LinuxFileException linuxFileException;

  _XSMBService_DeleteFile_result__isset __isset;

  void __set_success(const LinuxFileResponse& val);

  void __set_linuxFileException(const LinuxFileException& val);

  bool operator == (const XSMBService_DeleteFile_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(linuxFileException == rhs.linuxFileException))
      return false;
    return true;
  }
  bool operator != (const XSMBService_DeleteFile_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_DeleteFile_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_DeleteFile_result& obj);
};

typedef struct _XSMBService_DeleteFile_presult__isset {
  _XSMBService_DeleteFile_presult__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_DeleteFile_presult__isset;

class XSMBService_DeleteFile_presult {
 public:

  static const char* ascii_fingerprint; // = "ACEF167A387B2A5EA3E03B91E107CA4D";
  static const uint8_t binary_fingerprint[16]; // = {0xAC,0xEF,0x16,0x7A,0x38,0x7B,0x2A,0x5E,0xA3,0xE0,0x3B,0x91,0xE1,0x07,0xCA,0x4D};


  virtual ~XSMBService_DeleteFile_presult() throw();
  LinuxFileResponse* success;
  LinuxFileException linuxFileException;

  _XSMBService_DeleteFile_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_DeleteFile_presult& obj);
};

typedef struct _XSMBService_ReadFile_args__isset {
  _XSMBService_ReadFile_args__isset() : filePath(false), data(false), noBuffering(false), fileVersion(false), useVersionInData(false), keyName(false) {}
  bool filePath :1;
  bool data :1;
  bool noBuffering :1;
  bool fileVersion :1;
  bool useVersionInData :1;
  bool keyName :1;
} _XSMBService_ReadFile_args__isset;

class XSMBService_ReadFile_args {
 public:

  static const char* ascii_fingerprint; // = "A37B9CD06DE2019E86710553E3837C1C";
  static const uint8_t binary_fingerprint[16]; // = {0xA3,0x7B,0x9C,0xD0,0x6D,0xE2,0x01,0x9E,0x86,0x71,0x05,0x53,0xE3,0x83,0x7C,0x1C};

  XSMBService_ReadFile_args(const XSMBService_ReadFile_args&);
  XSMBService_ReadFile_args& operator=(const XSMBService_ReadFile_args&);
  XSMBService_ReadFile_args() : filePath(), noBuffering(0), fileVersion(0), useVersionInData(0), keyName() {
  }

  virtual ~XSMBService_ReadFile_args() throw();
  std::string filePath;
  StreamDataLayout data;
  bool noBuffering;
  int8_t fileVersion;
  bool useVersionInData;
  std::string keyName;

  _XSMBService_ReadFile_args__isset __isset;

  void __set_filePath(const std::string& val);

  void __set_data(const StreamDataLayout& val);

  void __set_noBuffering(const bool val);

  void __set_fileVersion(const int8_t val);

  void __set_useVersionInData(const bool val);

  void __set_keyName(const std::string& val);

  bool operator == (const XSMBService_ReadFile_args & rhs) const
  {
    if (!(filePath == rhs.filePath))
      return false;
    if (!(data == rhs.data))
      return false;
    if (!(noBuffering == rhs.noBuffering))
      return false;
    if (!(fileVersion == rhs.fileVersion))
      return false;
    if (!(useVersionInData == rhs.useVersionInData))
      return false;
    if (!(keyName == rhs.keyName))
      return false;
    return true;
  }
  bool operator != (const XSMBService_ReadFile_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_ReadFile_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_ReadFile_args& obj);
};


class XSMBService_ReadFile_pargs {
 public:

  static const char* ascii_fingerprint; // = "A37B9CD06DE2019E86710553E3837C1C";
  static const uint8_t binary_fingerprint[16]; // = {0xA3,0x7B,0x9C,0xD0,0x6D,0xE2,0x01,0x9E,0x86,0x71,0x05,0x53,0xE3,0x83,0x7C,0x1C};


  virtual ~XSMBService_ReadFile_pargs() throw();
  const std::string* filePath;
  const StreamDataLayout* data;
  const bool* noBuffering;
  const int8_t* fileVersion;
  const bool* useVersionInData;
  const std::string* keyName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_ReadFile_pargs& obj);
};

typedef struct _XSMBService_ReadFile_result__isset {
  _XSMBService_ReadFile_result__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_ReadFile_result__isset;

class XSMBService_ReadFile_result {
 public:

  static const char* ascii_fingerprint; // = "ACEF167A387B2A5EA3E03B91E107CA4D";
  static const uint8_t binary_fingerprint[16]; // = {0xAC,0xEF,0x16,0x7A,0x38,0x7B,0x2A,0x5E,0xA3,0xE0,0x3B,0x91,0xE1,0x07,0xCA,0x4D};

  XSMBService_ReadFile_result(const XSMBService_ReadFile_result&);
  XSMBService_ReadFile_result& operator=(const XSMBService_ReadFile_result&);
  XSMBService_ReadFile_result() {
  }

  virtual ~XSMBService_ReadFile_result() throw();
  LinuxFileResponse success;
  LinuxFileException linuxFileException;

  _XSMBService_ReadFile_result__isset __isset;

  void __set_success(const LinuxFileResponse& val);

  void __set_linuxFileException(const LinuxFileException& val);

  bool operator == (const XSMBService_ReadFile_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(linuxFileException == rhs.linuxFileException))
      return false;
    return true;
  }
  bool operator != (const XSMBService_ReadFile_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_ReadFile_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_ReadFile_result& obj);
};

typedef struct _XSMBService_ReadFile_presult__isset {
  _XSMBService_ReadFile_presult__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_ReadFile_presult__isset;

class XSMBService_ReadFile_presult {
 public:

  static const char* ascii_fingerprint; // = "ACEF167A387B2A5EA3E03B91E107CA4D";
  static const uint8_t binary_fingerprint[16]; // = {0xAC,0xEF,0x16,0x7A,0x38,0x7B,0x2A,0x5E,0xA3,0xE0,0x3B,0x91,0xE1,0x07,0xCA,0x4D};


  virtual ~XSMBService_ReadFile_presult() throw();
  LinuxFileResponse* success;
  LinuxFileException linuxFileException;

  _XSMBService_ReadFile_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_ReadFile_presult& obj);
};

typedef struct _XSMBService_WriteFile_args__isset {
  _XSMBService_WriteFile_args__isset() : filePath(false), data(false), noBuffering(false), fileVersion(false), useVersionInData(false), keyName(false) {}
  bool filePath :1;
  bool data :1;
  bool noBuffering :1;
  bool fileVersion :1;
  bool useVersionInData :1;
  bool keyName :1;
} _XSMBService_WriteFile_args__isset;

class XSMBService_WriteFile_args {
 public:

  static const char* ascii_fingerprint; // = "A37B9CD06DE2019E86710553E3837C1C";
  static const uint8_t binary_fingerprint[16]; // = {0xA3,0x7B,0x9C,0xD0,0x6D,0xE2,0x01,0x9E,0x86,0x71,0x05,0x53,0xE3,0x83,0x7C,0x1C};

  XSMBService_WriteFile_args(const XSMBService_WriteFile_args&);
  XSMBService_WriteFile_args& operator=(const XSMBService_WriteFile_args&);
  XSMBService_WriteFile_args() : filePath(), noBuffering(0), fileVersion(0), useVersionInData(0), keyName() {
  }

  virtual ~XSMBService_WriteFile_args() throw();
  std::string filePath;
  StreamDataLayout data;
  bool noBuffering;
  int8_t fileVersion;
  bool useVersionInData;
  std::string keyName;

  _XSMBService_WriteFile_args__isset __isset;

  void __set_filePath(const std::string& val);

  void __set_data(const StreamDataLayout& val);

  void __set_noBuffering(const bool val);

  void __set_fileVersion(const int8_t val);

  void __set_useVersionInData(const bool val);

  void __set_keyName(const std::string& val);

  bool operator == (const XSMBService_WriteFile_args & rhs) const
  {
    if (!(filePath == rhs.filePath))
      return false;
    if (!(data == rhs.data))
      return false;
    if (!(noBuffering == rhs.noBuffering))
      return false;
    if (!(fileVersion == rhs.fileVersion))
      return false;
    if (!(useVersionInData == rhs.useVersionInData))
      return false;
    if (!(keyName == rhs.keyName))
      return false;
    return true;
  }
  bool operator != (const XSMBService_WriteFile_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_WriteFile_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_WriteFile_args& obj);
};


class XSMBService_WriteFile_pargs {
 public:

  static const char* ascii_fingerprint; // = "A37B9CD06DE2019E86710553E3837C1C";
  static const uint8_t binary_fingerprint[16]; // = {0xA3,0x7B,0x9C,0xD0,0x6D,0xE2,0x01,0x9E,0x86,0x71,0x05,0x53,0xE3,0x83,0x7C,0x1C};


  virtual ~XSMBService_WriteFile_pargs() throw();
  const std::string* filePath;
  const StreamDataLayout* data;
  const bool* noBuffering;
  const int8_t* fileVersion;
  const bool* useVersionInData;
  const std::string* keyName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_WriteFile_pargs& obj);
};

typedef struct _XSMBService_WriteFile_result__isset {
  _XSMBService_WriteFile_result__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_WriteFile_result__isset;

class XSMBService_WriteFile_result {
 public:

  static const char* ascii_fingerprint; // = "ACEF167A387B2A5EA3E03B91E107CA4D";
  static const uint8_t binary_fingerprint[16]; // = {0xAC,0xEF,0x16,0x7A,0x38,0x7B,0x2A,0x5E,0xA3,0xE0,0x3B,0x91,0xE1,0x07,0xCA,0x4D};

  XSMBService_WriteFile_result(const XSMBService_WriteFile_result&);
  XSMBService_WriteFile_result& operator=(const XSMBService_WriteFile_result&);
  XSMBService_WriteFile_result() {
  }

  virtual ~XSMBService_WriteFile_result() throw();
  LinuxFileResponse success;
  LinuxFileException linuxFileException;

  _XSMBService_WriteFile_result__isset __isset;

  void __set_success(const LinuxFileResponse& val);

  void __set_linuxFileException(const LinuxFileException& val);

  bool operator == (const XSMBService_WriteFile_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(linuxFileException == rhs.linuxFileException))
      return false;
    return true;
  }
  bool operator != (const XSMBService_WriteFile_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_WriteFile_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_WriteFile_result& obj);
};

typedef struct _XSMBService_WriteFile_presult__isset {
  _XSMBService_WriteFile_presult__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_WriteFile_presult__isset;

class XSMBService_WriteFile_presult {
 public:

  static const char* ascii_fingerprint; // = "ACEF167A387B2A5EA3E03B91E107CA4D";
  static const uint8_t binary_fingerprint[16]; // = {0xAC,0xEF,0x16,0x7A,0x38,0x7B,0x2A,0x5E,0xA3,0xE0,0x3B,0x91,0xE1,0x07,0xCA,0x4D};


  virtual ~XSMBService_WriteFile_presult() throw();
  LinuxFileResponse* success;
  LinuxFileException linuxFileException;

  _XSMBService_WriteFile_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_WriteFile_presult& obj);
};

typedef struct _XSMBService_ListCloudFiles_args__isset {
  _XSMBService_ListCloudFiles_args__isset() : dirPath(false), isRecursive(false), files(false), dirs(false) {}
  bool dirPath :1;
  bool isRecursive :1;
  bool files :1;
  bool dirs :1;
} _XSMBService_ListCloudFiles_args__isset;

class XSMBService_ListCloudFiles_args {
 public:

  static const char* ascii_fingerprint; // = "5286B143CB4AD85C8386E2D2D6CF54BF";
  static const uint8_t binary_fingerprint[16]; // = {0x52,0x86,0xB1,0x43,0xCB,0x4A,0xD8,0x5C,0x83,0x86,0xE2,0xD2,0xD6,0xCF,0x54,0xBF};

  XSMBService_ListCloudFiles_args(const XSMBService_ListCloudFiles_args&);
  XSMBService_ListCloudFiles_args& operator=(const XSMBService_ListCloudFiles_args&);
  XSMBService_ListCloudFiles_args() : dirPath(), isRecursive(0) {
  }

  virtual ~XSMBService_ListCloudFiles_args() throw();
  std::string dirPath;
  bool isRecursive;
  std::map<std::string, MatchInformation::type>  files;
  std::map<std::string, MatchInformation::type>  dirs;

  _XSMBService_ListCloudFiles_args__isset __isset;

  void __set_dirPath(const std::string& val);

  void __set_isRecursive(const bool val);

  void __set_files(const std::map<std::string, MatchInformation::type> & val);

  void __set_dirs(const std::map<std::string, MatchInformation::type> & val);

  bool operator == (const XSMBService_ListCloudFiles_args & rhs) const
  {
    if (!(dirPath == rhs.dirPath))
      return false;
    if (!(isRecursive == rhs.isRecursive))
      return false;
    if (!(files == rhs.files))
      return false;
    if (!(dirs == rhs.dirs))
      return false;
    return true;
  }
  bool operator != (const XSMBService_ListCloudFiles_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_ListCloudFiles_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_ListCloudFiles_args& obj);
};


class XSMBService_ListCloudFiles_pargs {
 public:

  static const char* ascii_fingerprint; // = "5286B143CB4AD85C8386E2D2D6CF54BF";
  static const uint8_t binary_fingerprint[16]; // = {0x52,0x86,0xB1,0x43,0xCB,0x4A,0xD8,0x5C,0x83,0x86,0xE2,0xD2,0xD6,0xCF,0x54,0xBF};


  virtual ~XSMBService_ListCloudFiles_pargs() throw();
  const std::string* dirPath;
  const bool* isRecursive;
  const std::map<std::string, MatchInformation::type> * files;
  const std::map<std::string, MatchInformation::type> * dirs;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_ListCloudFiles_pargs& obj);
};

typedef struct _XSMBService_ListCloudFiles_result__isset {
  _XSMBService_ListCloudFiles_result__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_ListCloudFiles_result__isset;

class XSMBService_ListCloudFiles_result {
 public:

  static const char* ascii_fingerprint; // = "ACEF167A387B2A5EA3E03B91E107CA4D";
  static const uint8_t binary_fingerprint[16]; // = {0xAC,0xEF,0x16,0x7A,0x38,0x7B,0x2A,0x5E,0xA3,0xE0,0x3B,0x91,0xE1,0x07,0xCA,0x4D};

  XSMBService_ListCloudFiles_result(const XSMBService_ListCloudFiles_result&);
  XSMBService_ListCloudFiles_result& operator=(const XSMBService_ListCloudFiles_result&);
  XSMBService_ListCloudFiles_result() {
  }

  virtual ~XSMBService_ListCloudFiles_result() throw();
  LinuxFileResponse success;
  LinuxFileException linuxFileException;

  _XSMBService_ListCloudFiles_result__isset __isset;

  void __set_success(const LinuxFileResponse& val);

  void __set_linuxFileException(const LinuxFileException& val);

  bool operator == (const XSMBService_ListCloudFiles_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(linuxFileException == rhs.linuxFileException))
      return false;
    return true;
  }
  bool operator != (const XSMBService_ListCloudFiles_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_ListCloudFiles_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_ListCloudFiles_result& obj);
};

typedef struct _XSMBService_ListCloudFiles_presult__isset {
  _XSMBService_ListCloudFiles_presult__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_ListCloudFiles_presult__isset;

class XSMBService_ListCloudFiles_presult {
 public:

  static const char* ascii_fingerprint; // = "ACEF167A387B2A5EA3E03B91E107CA4D";
  static const uint8_t binary_fingerprint[16]; // = {0xAC,0xEF,0x16,0x7A,0x38,0x7B,0x2A,0x5E,0xA3,0xE0,0x3B,0x91,0xE1,0x07,0xCA,0x4D};


  virtual ~XSMBService_ListCloudFiles_presult() throw();
  LinuxFileResponse* success;
  LinuxFileException linuxFileException;

  _XSMBService_ListCloudFiles_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_ListCloudFiles_presult& obj);
};

typedef struct _XSMBService_GetCloudFileLength_args__isset {
  _XSMBService_GetCloudFileLength_args__isset() : filePath(false) {}
  bool filePath :1;
} _XSMBService_GetCloudFileLength_args__isset;

class XSMBService_GetCloudFileLength_args {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  XSMBService_GetCloudFileLength_args(const XSMBService_GetCloudFileLength_args&);
  XSMBService_GetCloudFileLength_args& operator=(const XSMBService_GetCloudFileLength_args&);
  XSMBService_GetCloudFileLength_args() : filePath() {
  }

  virtual ~XSMBService_GetCloudFileLength_args() throw();
  std::string filePath;

  _XSMBService_GetCloudFileLength_args__isset __isset;

  void __set_filePath(const std::string& val);

  bool operator == (const XSMBService_GetCloudFileLength_args & rhs) const
  {
    if (!(filePath == rhs.filePath))
      return false;
    return true;
  }
  bool operator != (const XSMBService_GetCloudFileLength_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_GetCloudFileLength_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_GetCloudFileLength_args& obj);
};


class XSMBService_GetCloudFileLength_pargs {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};


  virtual ~XSMBService_GetCloudFileLength_pargs() throw();
  const std::string* filePath;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_GetCloudFileLength_pargs& obj);
};

typedef struct _XSMBService_GetCloudFileLength_result__isset {
  _XSMBService_GetCloudFileLength_result__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_GetCloudFileLength_result__isset;

class XSMBService_GetCloudFileLength_result {
 public:

  static const char* ascii_fingerprint; // = "6B615A494D4BCB837D782F2ADBF7E19A";
  static const uint8_t binary_fingerprint[16]; // = {0x6B,0x61,0x5A,0x49,0x4D,0x4B,0xCB,0x83,0x7D,0x78,0x2F,0x2A,0xDB,0xF7,0xE1,0x9A};

  XSMBService_GetCloudFileLength_result(const XSMBService_GetCloudFileLength_result&);
  XSMBService_GetCloudFileLength_result& operator=(const XSMBService_GetCloudFileLength_result&);
  XSMBService_GetCloudFileLength_result() : success(0) {
  }

  virtual ~XSMBService_GetCloudFileLength_result() throw();
  int64_t success;
  LinuxFileException linuxFileException;

  _XSMBService_GetCloudFileLength_result__isset __isset;

  void __set_success(const int64_t val);

  void __set_linuxFileException(const LinuxFileException& val);

  bool operator == (const XSMBService_GetCloudFileLength_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(linuxFileException == rhs.linuxFileException))
      return false;
    return true;
  }
  bool operator != (const XSMBService_GetCloudFileLength_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_GetCloudFileLength_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_GetCloudFileLength_result& obj);
};

typedef struct _XSMBService_GetCloudFileLength_presult__isset {
  _XSMBService_GetCloudFileLength_presult__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_GetCloudFileLength_presult__isset;

class XSMBService_GetCloudFileLength_presult {
 public:

  static const char* ascii_fingerprint; // = "6B615A494D4BCB837D782F2ADBF7E19A";
  static const uint8_t binary_fingerprint[16]; // = {0x6B,0x61,0x5A,0x49,0x4D,0x4B,0xCB,0x83,0x7D,0x78,0x2F,0x2A,0xDB,0xF7,0xE1,0x9A};


  virtual ~XSMBService_GetCloudFileLength_presult() throw();
  int64_t* success;
  LinuxFileException linuxFileException;

  _XSMBService_GetCloudFileLength_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_GetCloudFileLength_presult& obj);
};

typedef struct _XSMBService_SetCloudFileLength_args__isset {
  _XSMBService_SetCloudFileLength_args__isset() : filePath(false), fileLength(false) {}
  bool filePath :1;
  bool fileLength :1;
} _XSMBService_SetCloudFileLength_args__isset;

class XSMBService_SetCloudFileLength_args {
 public:

  static const char* ascii_fingerprint; // = "1CCCF6FC31CFD1D61BBBB1BAF3590620";
  static const uint8_t binary_fingerprint[16]; // = {0x1C,0xCC,0xF6,0xFC,0x31,0xCF,0xD1,0xD6,0x1B,0xBB,0xB1,0xBA,0xF3,0x59,0x06,0x20};

  XSMBService_SetCloudFileLength_args(const XSMBService_SetCloudFileLength_args&);
  XSMBService_SetCloudFileLength_args& operator=(const XSMBService_SetCloudFileLength_args&);
  XSMBService_SetCloudFileLength_args() : filePath(), fileLength(0) {
  }

  virtual ~XSMBService_SetCloudFileLength_args() throw();
  std::string filePath;
  int64_t fileLength;

  _XSMBService_SetCloudFileLength_args__isset __isset;

  void __set_filePath(const std::string& val);

  void __set_fileLength(const int64_t val);

  bool operator == (const XSMBService_SetCloudFileLength_args & rhs) const
  {
    if (!(filePath == rhs.filePath))
      return false;
    if (!(fileLength == rhs.fileLength))
      return false;
    return true;
  }
  bool operator != (const XSMBService_SetCloudFileLength_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_SetCloudFileLength_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_SetCloudFileLength_args& obj);
};


class XSMBService_SetCloudFileLength_pargs {
 public:

  static const char* ascii_fingerprint; // = "1CCCF6FC31CFD1D61BBBB1BAF3590620";
  static const uint8_t binary_fingerprint[16]; // = {0x1C,0xCC,0xF6,0xFC,0x31,0xCF,0xD1,0xD6,0x1B,0xBB,0xB1,0xBA,0xF3,0x59,0x06,0x20};


  virtual ~XSMBService_SetCloudFileLength_pargs() throw();
  const std::string* filePath;
  const int64_t* fileLength;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_SetCloudFileLength_pargs& obj);
};

typedef struct _XSMBService_SetCloudFileLength_result__isset {
  _XSMBService_SetCloudFileLength_result__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_SetCloudFileLength_result__isset;

class XSMBService_SetCloudFileLength_result {
 public:

  static const char* ascii_fingerprint; // = "ACEF167A387B2A5EA3E03B91E107CA4D";
  static const uint8_t binary_fingerprint[16]; // = {0xAC,0xEF,0x16,0x7A,0x38,0x7B,0x2A,0x5E,0xA3,0xE0,0x3B,0x91,0xE1,0x07,0xCA,0x4D};

  XSMBService_SetCloudFileLength_result(const XSMBService_SetCloudFileLength_result&);
  XSMBService_SetCloudFileLength_result& operator=(const XSMBService_SetCloudFileLength_result&);
  XSMBService_SetCloudFileLength_result() {
  }

  virtual ~XSMBService_SetCloudFileLength_result() throw();
  LinuxFileResponse success;
  LinuxFileException linuxFileException;

  _XSMBService_SetCloudFileLength_result__isset __isset;

  void __set_success(const LinuxFileResponse& val);

  void __set_linuxFileException(const LinuxFileException& val);

  bool operator == (const XSMBService_SetCloudFileLength_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(linuxFileException == rhs.linuxFileException))
      return false;
    return true;
  }
  bool operator != (const XSMBService_SetCloudFileLength_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_SetCloudFileLength_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_SetCloudFileLength_result& obj);
};

typedef struct _XSMBService_SetCloudFileLength_presult__isset {
  _XSMBService_SetCloudFileLength_presult__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_SetCloudFileLength_presult__isset;

class XSMBService_SetCloudFileLength_presult {
 public:

  static const char* ascii_fingerprint; // = "ACEF167A387B2A5EA3E03B91E107CA4D";
  static const uint8_t binary_fingerprint[16]; // = {0xAC,0xEF,0x16,0x7A,0x38,0x7B,0x2A,0x5E,0xA3,0xE0,0x3B,0x91,0xE1,0x07,0xCA,0x4D};


  virtual ~XSMBService_SetCloudFileLength_presult() throw();
  LinuxFileResponse* success;
  LinuxFileException linuxFileException;

  _XSMBService_SetCloudFileLength_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_SetCloudFileLength_presult& obj);
};

class XSMBServiceClient : virtual public XSMBServiceIf {
 public:
  XSMBServiceClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  XSMBServiceClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void CreateDirectory(LinuxFileResponse& _return, const std::string& dirPath);
  void send_CreateDirectory(const std::string& dirPath);
  void recv_CreateDirectory(LinuxFileResponse& _return);
  void DeleteDirectory(LinuxFileResponse& _return, const std::string& dirPath, const bool isRecursive);
  void send_DeleteDirectory(const std::string& dirPath, const bool isRecursive);
  void recv_DeleteDirectory(LinuxFileResponse& _return);
  void CreateFile(LinuxFileResponse& _return, const std::string& filePath, const int64_t fileSize, const bool noBuffering);
  void send_CreateFile(const std::string& filePath, const int64_t fileSize, const bool noBuffering);
  void recv_CreateFile(LinuxFileResponse& _return);
  void DeleteFile(LinuxFileResponse& _return, const std::string& filePath);
  void send_DeleteFile(const std::string& filePath);
  void recv_DeleteFile(LinuxFileResponse& _return);
  void ReadFile(LinuxFileResponse& _return, const std::string& filePath, const StreamDataLayout& data, const bool noBuffering, const int8_t fileVersion, const bool useVersionInData, const std::string& keyName);
  void send_ReadFile(const std::string& filePath, const StreamDataLayout& data, const bool noBuffering, const int8_t fileVersion, const bool useVersionInData, const std::string& keyName);
  void recv_ReadFile(LinuxFileResponse& _return);
  void WriteFile(LinuxFileResponse& _return, const std::string& filePath, const StreamDataLayout& data, const bool noBuffering, const int8_t fileVersion, const bool useVersionInData, const std::string& keyName);
  void send_WriteFile(const std::string& filePath, const StreamDataLayout& data, const bool noBuffering, const int8_t fileVersion, const bool useVersionInData, const std::string& keyName);
  void recv_WriteFile(LinuxFileResponse& _return);
  void ListCloudFiles(LinuxFileResponse& _return, const std::string& dirPath, const bool isRecursive, const std::map<std::string, MatchInformation::type> & files, const std::map<std::string, MatchInformation::type> & dirs);
  void send_ListCloudFiles(const std::string& dirPath, const bool isRecursive, const std::map<std::string, MatchInformation::type> & files, const std::map<std::string, MatchInformation::type> & dirs);
  void recv_ListCloudFiles(LinuxFileResponse& _return);
  int64_t GetCloudFileLength(const std::string& filePath);
  void send_GetCloudFileLength(const std::string& filePath);
  int64_t recv_GetCloudFileLength();
  void SetCloudFileLength(LinuxFileResponse& _return, const std::string& filePath, const int64_t fileLength);
  void send_SetCloudFileLength(const std::string& filePath, const int64_t fileLength);
  void recv_SetCloudFileLength(LinuxFileResponse& _return);
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class XSMBServiceProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  boost::shared_ptr<XSMBServiceIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (XSMBServiceProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_CreateDirectory(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_DeleteDirectory(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_CreateFile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_DeleteFile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_ReadFile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_WriteFile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_ListCloudFiles(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_GetCloudFileLength(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_SetCloudFileLength(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  XSMBServiceProcessor(boost::shared_ptr<XSMBServiceIf> iface) :
    iface_(iface) {
    processMap_["CreateDirectory"] = &XSMBServiceProcessor::process_CreateDirectory;
    processMap_["DeleteDirectory"] = &XSMBServiceProcessor::process_DeleteDirectory;
    processMap_["CreateFile"] = &XSMBServiceProcessor::process_CreateFile;
    processMap_["DeleteFile"] = &XSMBServiceProcessor::process_DeleteFile;
    processMap_["ReadFile"] = &XSMBServiceProcessor::process_ReadFile;
    processMap_["WriteFile"] = &XSMBServiceProcessor::process_WriteFile;
    processMap_["ListCloudFiles"] = &XSMBServiceProcessor::process_ListCloudFiles;
    processMap_["GetCloudFileLength"] = &XSMBServiceProcessor::process_GetCloudFileLength;
    processMap_["SetCloudFileLength"] = &XSMBServiceProcessor::process_SetCloudFileLength;
  }

  virtual ~XSMBServiceProcessor() {}
};

class XSMBServiceProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  XSMBServiceProcessorFactory(const ::boost::shared_ptr< XSMBServiceIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::boost::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::boost::shared_ptr< XSMBServiceIfFactory > handlerFactory_;
};

class XSMBServiceMultiface : virtual public XSMBServiceIf {
 public:
  XSMBServiceMultiface(std::vector<boost::shared_ptr<XSMBServiceIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~XSMBServiceMultiface() {}
 protected:
  std::vector<boost::shared_ptr<XSMBServiceIf> > ifaces_;
  XSMBServiceMultiface() {}
  void add(boost::shared_ptr<XSMBServiceIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void CreateDirectory(LinuxFileResponse& _return, const std::string& dirPath) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->CreateDirectory(_return, dirPath);
    }
    ifaces_[i]->CreateDirectory(_return, dirPath);
    return;
  }

  void DeleteDirectory(LinuxFileResponse& _return, const std::string& dirPath, const bool isRecursive) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->DeleteDirectory(_return, dirPath, isRecursive);
    }
    ifaces_[i]->DeleteDirectory(_return, dirPath, isRecursive);
    return;
  }

  void CreateFile(LinuxFileResponse& _return, const std::string& filePath, const int64_t fileSize, const bool noBuffering) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->CreateFile(_return, filePath, fileSize, noBuffering);
    }
    ifaces_[i]->CreateFile(_return, filePath, fileSize, noBuffering);
    return;
  }

  void DeleteFile(LinuxFileResponse& _return, const std::string& filePath) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->DeleteFile(_return, filePath);
    }
    ifaces_[i]->DeleteFile(_return, filePath);
    return;
  }

  void ReadFile(LinuxFileResponse& _return, const std::string& filePath, const StreamDataLayout& data, const bool noBuffering, const int8_t fileVersion, const bool useVersionInData, const std::string& keyName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->ReadFile(_return, filePath, data, noBuffering, fileVersion, useVersionInData, keyName);
    }
    ifaces_[i]->ReadFile(_return, filePath, data, noBuffering, fileVersion, useVersionInData, keyName);
    return;
  }

  void WriteFile(LinuxFileResponse& _return, const std::string& filePath, const StreamDataLayout& data, const bool noBuffering, const int8_t fileVersion, const bool useVersionInData, const std::string& keyName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->WriteFile(_return, filePath, data, noBuffering, fileVersion, useVersionInData, keyName);
    }
    ifaces_[i]->WriteFile(_return, filePath, data, noBuffering, fileVersion, useVersionInData, keyName);
    return;
  }

  void ListCloudFiles(LinuxFileResponse& _return, const std::string& dirPath, const bool isRecursive, const std::map<std::string, MatchInformation::type> & files, const std::map<std::string, MatchInformation::type> & dirs) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->ListCloudFiles(_return, dirPath, isRecursive, files, dirs);
    }
    ifaces_[i]->ListCloudFiles(_return, dirPath, isRecursive, files, dirs);
    return;
  }

  int64_t GetCloudFileLength(const std::string& filePath) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->GetCloudFileLength(filePath);
    }
    return ifaces_[i]->GetCloudFileLength(filePath);
  }

  void SetCloudFileLength(LinuxFileResponse& _return, const std::string& filePath, const int64_t fileLength) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->SetCloudFileLength(_return, filePath, fileLength);
    }
    ifaces_[i]->SetCloudFileLength(_return, filePath, fileLength);
    return;
  }

};

}}} // namespace

#endif
