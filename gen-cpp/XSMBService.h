/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef XSMBService_H
#define XSMBService_H

#include <thrift/TDispatchProcessor.h>
#include "cpp_linux_types.h"

namespace azure { namespace storage { namespace cpp_linux {

class XSMBServiceIf {
 public:
  virtual ~XSMBServiceIf() {}
  virtual void PathExists(LinuxFileResponse& _return, const std::string& path) = 0;
  virtual void CreateDirectory(LinuxFileResponse& _return, const std::string& dirPath) = 0;
  virtual void CopyFile(LinuxFileResponse& _return, const std::string& sourcePath, const std::string& destinationPath, const bool overwriteIfExists) = 0;
  virtual void DeleteDirectory(LinuxFileResponse& _return, const std::string& dirPath, const bool isRecursive) = 0;
  virtual void CreateFile(LinuxFileResponse& _return, const std::string& filePath, const int64_t fileSize, const bool noBuffering) = 0;
  virtual void DeleteFile(LinuxFileResponse& _return, const std::string& filePath) = 0;
  virtual void ReadFile(LinuxFileResponse& _return, const std::string& filePath, const int64_t offset, const int64_t count) = 0;
  virtual void WriteFile(LinuxFileResponse& _return, const std::string& filePath, const int64_t offset, const std::string& buffer, const int64_t count) = 0;
  virtual void ListFiles(LinuxFileResponse& _return, const std::string& dirPath, const bool isRecursive) = 0;
  virtual void GetFileLength(LinuxFileResponse& _return, const std::string& filePath) = 0;
  virtual void SetFileLength(LinuxFileResponse& _return, const std::string& filePath, const int64_t fileLength) = 0;
  virtual void OpenFileHandle(LinuxFileResponse& _return, const std::string& filePath, const LinuxFileMode::type fileMode, const LinuxFileAccess::type fileAccess, const int32_t handleId) = 0;
  virtual void CloseFileHandle(LinuxFileResponse& _return, const int32_t handleId) = 0;
  virtual void ReadFileByHandle(LinuxFileResponse& _return, const int32_t handleId, const int64_t offset, const int64_t count) = 0;
  virtual void WriteFileByHandle(LinuxFileResponse& _return, const int32_t handleId, const int64_t offset, const std::string& buffer, const int64_t count) = 0;
  virtual void MoveFile(LinuxFileResponse& _return, const std::string& sourcePath, const std::string& destinationPath, const bool overwriteIfExists, const bool fileCopyAllowed) = 0;
};

class XSMBServiceIfFactory {
 public:
  typedef XSMBServiceIf Handler;

  virtual ~XSMBServiceIfFactory() {}

  virtual XSMBServiceIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(XSMBServiceIf* /* handler */) = 0;
};

class XSMBServiceIfSingletonFactory : virtual public XSMBServiceIfFactory {
 public:
  XSMBServiceIfSingletonFactory(const boost::shared_ptr<XSMBServiceIf>& iface) : iface_(iface) {}
  virtual ~XSMBServiceIfSingletonFactory() {}

  virtual XSMBServiceIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(XSMBServiceIf* /* handler */) {}

 protected:
  boost::shared_ptr<XSMBServiceIf> iface_;
};

class XSMBServiceNull : virtual public XSMBServiceIf {
 public:
  virtual ~XSMBServiceNull() {}
  void PathExists(LinuxFileResponse& /* _return */, const std::string& /* path */) {
    return;
  }
  void CreateDirectory(LinuxFileResponse& /* _return */, const std::string& /* dirPath */) {
    return;
  }
  void CopyFile(LinuxFileResponse& /* _return */, const std::string& /* sourcePath */, const std::string& /* destinationPath */, const bool /* overwriteIfExists */) {
    return;
  }
  void DeleteDirectory(LinuxFileResponse& /* _return */, const std::string& /* dirPath */, const bool /* isRecursive */) {
    return;
  }
  void CreateFile(LinuxFileResponse& /* _return */, const std::string& /* filePath */, const int64_t /* fileSize */, const bool /* noBuffering */) {
    return;
  }
  void DeleteFile(LinuxFileResponse& /* _return */, const std::string& /* filePath */) {
    return;
  }
  void ReadFile(LinuxFileResponse& /* _return */, const std::string& /* filePath */, const int64_t /* offset */, const int64_t /* count */) {
    return;
  }
  void WriteFile(LinuxFileResponse& /* _return */, const std::string& /* filePath */, const int64_t /* offset */, const std::string& /* buffer */, const int64_t /* count */) {
    return;
  }
  void ListFiles(LinuxFileResponse& /* _return */, const std::string& /* dirPath */, const bool /* isRecursive */) {
    return;
  }
  void GetFileLength(LinuxFileResponse& /* _return */, const std::string& /* filePath */) {
    return;
  }
  void SetFileLength(LinuxFileResponse& /* _return */, const std::string& /* filePath */, const int64_t /* fileLength */) {
    return;
  }
  void OpenFileHandle(LinuxFileResponse& /* _return */, const std::string& /* filePath */, const LinuxFileMode::type /* fileMode */, const LinuxFileAccess::type /* fileAccess */, const int32_t /* handleId */) {
    return;
  }
  void CloseFileHandle(LinuxFileResponse& /* _return */, const int32_t /* handleId */) {
    return;
  }
  void ReadFileByHandle(LinuxFileResponse& /* _return */, const int32_t /* handleId */, const int64_t /* offset */, const int64_t /* count */) {
    return;
  }
  void WriteFileByHandle(LinuxFileResponse& /* _return */, const int32_t /* handleId */, const int64_t /* offset */, const std::string& /* buffer */, const int64_t /* count */) {
    return;
  }
  void MoveFile(LinuxFileResponse& /* _return */, const std::string& /* sourcePath */, const std::string& /* destinationPath */, const bool /* overwriteIfExists */, const bool /* fileCopyAllowed */) {
    return;
  }
};

typedef struct _XSMBService_PathExists_args__isset {
  _XSMBService_PathExists_args__isset() : path(false) {}
  bool path :1;
} _XSMBService_PathExists_args__isset;

class XSMBService_PathExists_args {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  XSMBService_PathExists_args(const XSMBService_PathExists_args&);
  XSMBService_PathExists_args& operator=(const XSMBService_PathExists_args&);
  XSMBService_PathExists_args() : path() {
  }

  virtual ~XSMBService_PathExists_args() throw();
  std::string path;

  _XSMBService_PathExists_args__isset __isset;

  void __set_path(const std::string& val);

  bool operator == (const XSMBService_PathExists_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    return true;
  }
  bool operator != (const XSMBService_PathExists_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_PathExists_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_PathExists_args& obj);
};


class XSMBService_PathExists_pargs {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};


  virtual ~XSMBService_PathExists_pargs() throw();
  const std::string* path;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_PathExists_pargs& obj);
};

typedef struct _XSMBService_PathExists_result__isset {
  _XSMBService_PathExists_result__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_PathExists_result__isset;

class XSMBService_PathExists_result {
 public:

  static const char* ascii_fingerprint; // = "171C3835ABF08F842D8215E7F5C4BEB2";
  static const uint8_t binary_fingerprint[16]; // = {0x17,0x1C,0x38,0x35,0xAB,0xF0,0x8F,0x84,0x2D,0x82,0x15,0xE7,0xF5,0xC4,0xBE,0xB2};

  XSMBService_PathExists_result(const XSMBService_PathExists_result&);
  XSMBService_PathExists_result& operator=(const XSMBService_PathExists_result&);
  XSMBService_PathExists_result() {
  }

  virtual ~XSMBService_PathExists_result() throw();
  LinuxFileResponse success;
  LinuxFileException linuxFileException;

  _XSMBService_PathExists_result__isset __isset;

  void __set_success(const LinuxFileResponse& val);

  void __set_linuxFileException(const LinuxFileException& val);

  bool operator == (const XSMBService_PathExists_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(linuxFileException == rhs.linuxFileException))
      return false;
    return true;
  }
  bool operator != (const XSMBService_PathExists_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_PathExists_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_PathExists_result& obj);
};

typedef struct _XSMBService_PathExists_presult__isset {
  _XSMBService_PathExists_presult__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_PathExists_presult__isset;

class XSMBService_PathExists_presult {
 public:

  static const char* ascii_fingerprint; // = "171C3835ABF08F842D8215E7F5C4BEB2";
  static const uint8_t binary_fingerprint[16]; // = {0x17,0x1C,0x38,0x35,0xAB,0xF0,0x8F,0x84,0x2D,0x82,0x15,0xE7,0xF5,0xC4,0xBE,0xB2};


  virtual ~XSMBService_PathExists_presult() throw();
  LinuxFileResponse* success;
  LinuxFileException linuxFileException;

  _XSMBService_PathExists_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_PathExists_presult& obj);
};

typedef struct _XSMBService_CreateDirectory_args__isset {
  _XSMBService_CreateDirectory_args__isset() : dirPath(false) {}
  bool dirPath :1;
} _XSMBService_CreateDirectory_args__isset;

class XSMBService_CreateDirectory_args {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  XSMBService_CreateDirectory_args(const XSMBService_CreateDirectory_args&);
  XSMBService_CreateDirectory_args& operator=(const XSMBService_CreateDirectory_args&);
  XSMBService_CreateDirectory_args() : dirPath() {
  }

  virtual ~XSMBService_CreateDirectory_args() throw();
  std::string dirPath;

  _XSMBService_CreateDirectory_args__isset __isset;

  void __set_dirPath(const std::string& val);

  bool operator == (const XSMBService_CreateDirectory_args & rhs) const
  {
    if (!(dirPath == rhs.dirPath))
      return false;
    return true;
  }
  bool operator != (const XSMBService_CreateDirectory_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_CreateDirectory_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_CreateDirectory_args& obj);
};


class XSMBService_CreateDirectory_pargs {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};


  virtual ~XSMBService_CreateDirectory_pargs() throw();
  const std::string* dirPath;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_CreateDirectory_pargs& obj);
};

typedef struct _XSMBService_CreateDirectory_result__isset {
  _XSMBService_CreateDirectory_result__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_CreateDirectory_result__isset;

class XSMBService_CreateDirectory_result {
 public:

  static const char* ascii_fingerprint; // = "171C3835ABF08F842D8215E7F5C4BEB2";
  static const uint8_t binary_fingerprint[16]; // = {0x17,0x1C,0x38,0x35,0xAB,0xF0,0x8F,0x84,0x2D,0x82,0x15,0xE7,0xF5,0xC4,0xBE,0xB2};

  XSMBService_CreateDirectory_result(const XSMBService_CreateDirectory_result&);
  XSMBService_CreateDirectory_result& operator=(const XSMBService_CreateDirectory_result&);
  XSMBService_CreateDirectory_result() {
  }

  virtual ~XSMBService_CreateDirectory_result() throw();
  LinuxFileResponse success;
  LinuxFileException linuxFileException;

  _XSMBService_CreateDirectory_result__isset __isset;

  void __set_success(const LinuxFileResponse& val);

  void __set_linuxFileException(const LinuxFileException& val);

  bool operator == (const XSMBService_CreateDirectory_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(linuxFileException == rhs.linuxFileException))
      return false;
    return true;
  }
  bool operator != (const XSMBService_CreateDirectory_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_CreateDirectory_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_CreateDirectory_result& obj);
};

typedef struct _XSMBService_CreateDirectory_presult__isset {
  _XSMBService_CreateDirectory_presult__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_CreateDirectory_presult__isset;

class XSMBService_CreateDirectory_presult {
 public:

  static const char* ascii_fingerprint; // = "171C3835ABF08F842D8215E7F5C4BEB2";
  static const uint8_t binary_fingerprint[16]; // = {0x17,0x1C,0x38,0x35,0xAB,0xF0,0x8F,0x84,0x2D,0x82,0x15,0xE7,0xF5,0xC4,0xBE,0xB2};


  virtual ~XSMBService_CreateDirectory_presult() throw();
  LinuxFileResponse* success;
  LinuxFileException linuxFileException;

  _XSMBService_CreateDirectory_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_CreateDirectory_presult& obj);
};

typedef struct _XSMBService_CopyFile_args__isset {
  _XSMBService_CopyFile_args__isset() : sourcePath(false), destinationPath(false), overwriteIfExists(false) {}
  bool sourcePath :1;
  bool destinationPath :1;
  bool overwriteIfExists :1;
} _XSMBService_CopyFile_args__isset;

class XSMBService_CopyFile_args {
 public:

  static const char* ascii_fingerprint; // = "7F21FB535884165D6350077C7B970E93";
  static const uint8_t binary_fingerprint[16]; // = {0x7F,0x21,0xFB,0x53,0x58,0x84,0x16,0x5D,0x63,0x50,0x07,0x7C,0x7B,0x97,0x0E,0x93};

  XSMBService_CopyFile_args(const XSMBService_CopyFile_args&);
  XSMBService_CopyFile_args& operator=(const XSMBService_CopyFile_args&);
  XSMBService_CopyFile_args() : sourcePath(), destinationPath(), overwriteIfExists(0) {
  }

  virtual ~XSMBService_CopyFile_args() throw();
  std::string sourcePath;
  std::string destinationPath;
  bool overwriteIfExists;

  _XSMBService_CopyFile_args__isset __isset;

  void __set_sourcePath(const std::string& val);

  void __set_destinationPath(const std::string& val);

  void __set_overwriteIfExists(const bool val);

  bool operator == (const XSMBService_CopyFile_args & rhs) const
  {
    if (!(sourcePath == rhs.sourcePath))
      return false;
    if (!(destinationPath == rhs.destinationPath))
      return false;
    if (!(overwriteIfExists == rhs.overwriteIfExists))
      return false;
    return true;
  }
  bool operator != (const XSMBService_CopyFile_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_CopyFile_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_CopyFile_args& obj);
};


class XSMBService_CopyFile_pargs {
 public:

  static const char* ascii_fingerprint; // = "7F21FB535884165D6350077C7B970E93";
  static const uint8_t binary_fingerprint[16]; // = {0x7F,0x21,0xFB,0x53,0x58,0x84,0x16,0x5D,0x63,0x50,0x07,0x7C,0x7B,0x97,0x0E,0x93};


  virtual ~XSMBService_CopyFile_pargs() throw();
  const std::string* sourcePath;
  const std::string* destinationPath;
  const bool* overwriteIfExists;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_CopyFile_pargs& obj);
};

typedef struct _XSMBService_CopyFile_result__isset {
  _XSMBService_CopyFile_result__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_CopyFile_result__isset;

class XSMBService_CopyFile_result {
 public:

  static const char* ascii_fingerprint; // = "171C3835ABF08F842D8215E7F5C4BEB2";
  static const uint8_t binary_fingerprint[16]; // = {0x17,0x1C,0x38,0x35,0xAB,0xF0,0x8F,0x84,0x2D,0x82,0x15,0xE7,0xF5,0xC4,0xBE,0xB2};

  XSMBService_CopyFile_result(const XSMBService_CopyFile_result&);
  XSMBService_CopyFile_result& operator=(const XSMBService_CopyFile_result&);
  XSMBService_CopyFile_result() {
  }

  virtual ~XSMBService_CopyFile_result() throw();
  LinuxFileResponse success;
  LinuxFileException linuxFileException;

  _XSMBService_CopyFile_result__isset __isset;

  void __set_success(const LinuxFileResponse& val);

  void __set_linuxFileException(const LinuxFileException& val);

  bool operator == (const XSMBService_CopyFile_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(linuxFileException == rhs.linuxFileException))
      return false;
    return true;
  }
  bool operator != (const XSMBService_CopyFile_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_CopyFile_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_CopyFile_result& obj);
};

typedef struct _XSMBService_CopyFile_presult__isset {
  _XSMBService_CopyFile_presult__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_CopyFile_presult__isset;

class XSMBService_CopyFile_presult {
 public:

  static const char* ascii_fingerprint; // = "171C3835ABF08F842D8215E7F5C4BEB2";
  static const uint8_t binary_fingerprint[16]; // = {0x17,0x1C,0x38,0x35,0xAB,0xF0,0x8F,0x84,0x2D,0x82,0x15,0xE7,0xF5,0xC4,0xBE,0xB2};


  virtual ~XSMBService_CopyFile_presult() throw();
  LinuxFileResponse* success;
  LinuxFileException linuxFileException;

  _XSMBService_CopyFile_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_CopyFile_presult& obj);
};

typedef struct _XSMBService_DeleteDirectory_args__isset {
  _XSMBService_DeleteDirectory_args__isset() : dirPath(false), isRecursive(false) {}
  bool dirPath :1;
  bool isRecursive :1;
} _XSMBService_DeleteDirectory_args__isset;

class XSMBService_DeleteDirectory_args {
 public:

  static const char* ascii_fingerprint; // = "7D61C9AA00102AB4D8F72A1DA58297DC";
  static const uint8_t binary_fingerprint[16]; // = {0x7D,0x61,0xC9,0xAA,0x00,0x10,0x2A,0xB4,0xD8,0xF7,0x2A,0x1D,0xA5,0x82,0x97,0xDC};

  XSMBService_DeleteDirectory_args(const XSMBService_DeleteDirectory_args&);
  XSMBService_DeleteDirectory_args& operator=(const XSMBService_DeleteDirectory_args&);
  XSMBService_DeleteDirectory_args() : dirPath(), isRecursive(0) {
  }

  virtual ~XSMBService_DeleteDirectory_args() throw();
  std::string dirPath;
  bool isRecursive;

  _XSMBService_DeleteDirectory_args__isset __isset;

  void __set_dirPath(const std::string& val);

  void __set_isRecursive(const bool val);

  bool operator == (const XSMBService_DeleteDirectory_args & rhs) const
  {
    if (!(dirPath == rhs.dirPath))
      return false;
    if (!(isRecursive == rhs.isRecursive))
      return false;
    return true;
  }
  bool operator != (const XSMBService_DeleteDirectory_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_DeleteDirectory_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_DeleteDirectory_args& obj);
};


class XSMBService_DeleteDirectory_pargs {
 public:

  static const char* ascii_fingerprint; // = "7D61C9AA00102AB4D8F72A1DA58297DC";
  static const uint8_t binary_fingerprint[16]; // = {0x7D,0x61,0xC9,0xAA,0x00,0x10,0x2A,0xB4,0xD8,0xF7,0x2A,0x1D,0xA5,0x82,0x97,0xDC};


  virtual ~XSMBService_DeleteDirectory_pargs() throw();
  const std::string* dirPath;
  const bool* isRecursive;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_DeleteDirectory_pargs& obj);
};

typedef struct _XSMBService_DeleteDirectory_result__isset {
  _XSMBService_DeleteDirectory_result__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_DeleteDirectory_result__isset;

class XSMBService_DeleteDirectory_result {
 public:

  static const char* ascii_fingerprint; // = "171C3835ABF08F842D8215E7F5C4BEB2";
  static const uint8_t binary_fingerprint[16]; // = {0x17,0x1C,0x38,0x35,0xAB,0xF0,0x8F,0x84,0x2D,0x82,0x15,0xE7,0xF5,0xC4,0xBE,0xB2};

  XSMBService_DeleteDirectory_result(const XSMBService_DeleteDirectory_result&);
  XSMBService_DeleteDirectory_result& operator=(const XSMBService_DeleteDirectory_result&);
  XSMBService_DeleteDirectory_result() {
  }

  virtual ~XSMBService_DeleteDirectory_result() throw();
  LinuxFileResponse success;
  LinuxFileException linuxFileException;

  _XSMBService_DeleteDirectory_result__isset __isset;

  void __set_success(const LinuxFileResponse& val);

  void __set_linuxFileException(const LinuxFileException& val);

  bool operator == (const XSMBService_DeleteDirectory_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(linuxFileException == rhs.linuxFileException))
      return false;
    return true;
  }
  bool operator != (const XSMBService_DeleteDirectory_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_DeleteDirectory_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_DeleteDirectory_result& obj);
};

typedef struct _XSMBService_DeleteDirectory_presult__isset {
  _XSMBService_DeleteDirectory_presult__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_DeleteDirectory_presult__isset;

class XSMBService_DeleteDirectory_presult {
 public:

  static const char* ascii_fingerprint; // = "171C3835ABF08F842D8215E7F5C4BEB2";
  static const uint8_t binary_fingerprint[16]; // = {0x17,0x1C,0x38,0x35,0xAB,0xF0,0x8F,0x84,0x2D,0x82,0x15,0xE7,0xF5,0xC4,0xBE,0xB2};


  virtual ~XSMBService_DeleteDirectory_presult() throw();
  LinuxFileResponse* success;
  LinuxFileException linuxFileException;

  _XSMBService_DeleteDirectory_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_DeleteDirectory_presult& obj);
};

typedef struct _XSMBService_CreateFile_args__isset {
  _XSMBService_CreateFile_args__isset() : filePath(false), fileSize(false), noBuffering(false) {}
  bool filePath :1;
  bool fileSize :1;
  bool noBuffering :1;
} _XSMBService_CreateFile_args__isset;

class XSMBService_CreateFile_args {
 public:

  static const char* ascii_fingerprint; // = "B47B7A9B23016536A84872EAB968623F";
  static const uint8_t binary_fingerprint[16]; // = {0xB4,0x7B,0x7A,0x9B,0x23,0x01,0x65,0x36,0xA8,0x48,0x72,0xEA,0xB9,0x68,0x62,0x3F};

  XSMBService_CreateFile_args(const XSMBService_CreateFile_args&);
  XSMBService_CreateFile_args& operator=(const XSMBService_CreateFile_args&);
  XSMBService_CreateFile_args() : filePath(), fileSize(0), noBuffering(0) {
  }

  virtual ~XSMBService_CreateFile_args() throw();
  std::string filePath;
  int64_t fileSize;
  bool noBuffering;

  _XSMBService_CreateFile_args__isset __isset;

  void __set_filePath(const std::string& val);

  void __set_fileSize(const int64_t val);

  void __set_noBuffering(const bool val);

  bool operator == (const XSMBService_CreateFile_args & rhs) const
  {
    if (!(filePath == rhs.filePath))
      return false;
    if (!(fileSize == rhs.fileSize))
      return false;
    if (!(noBuffering == rhs.noBuffering))
      return false;
    return true;
  }
  bool operator != (const XSMBService_CreateFile_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_CreateFile_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_CreateFile_args& obj);
};


class XSMBService_CreateFile_pargs {
 public:

  static const char* ascii_fingerprint; // = "B47B7A9B23016536A84872EAB968623F";
  static const uint8_t binary_fingerprint[16]; // = {0xB4,0x7B,0x7A,0x9B,0x23,0x01,0x65,0x36,0xA8,0x48,0x72,0xEA,0xB9,0x68,0x62,0x3F};


  virtual ~XSMBService_CreateFile_pargs() throw();
  const std::string* filePath;
  const int64_t* fileSize;
  const bool* noBuffering;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_CreateFile_pargs& obj);
};

typedef struct _XSMBService_CreateFile_result__isset {
  _XSMBService_CreateFile_result__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_CreateFile_result__isset;

class XSMBService_CreateFile_result {
 public:

  static const char* ascii_fingerprint; // = "171C3835ABF08F842D8215E7F5C4BEB2";
  static const uint8_t binary_fingerprint[16]; // = {0x17,0x1C,0x38,0x35,0xAB,0xF0,0x8F,0x84,0x2D,0x82,0x15,0xE7,0xF5,0xC4,0xBE,0xB2};

  XSMBService_CreateFile_result(const XSMBService_CreateFile_result&);
  XSMBService_CreateFile_result& operator=(const XSMBService_CreateFile_result&);
  XSMBService_CreateFile_result() {
  }

  virtual ~XSMBService_CreateFile_result() throw();
  LinuxFileResponse success;
  LinuxFileException linuxFileException;

  _XSMBService_CreateFile_result__isset __isset;

  void __set_success(const LinuxFileResponse& val);

  void __set_linuxFileException(const LinuxFileException& val);

  bool operator == (const XSMBService_CreateFile_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(linuxFileException == rhs.linuxFileException))
      return false;
    return true;
  }
  bool operator != (const XSMBService_CreateFile_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_CreateFile_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_CreateFile_result& obj);
};

typedef struct _XSMBService_CreateFile_presult__isset {
  _XSMBService_CreateFile_presult__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_CreateFile_presult__isset;

class XSMBService_CreateFile_presult {
 public:

  static const char* ascii_fingerprint; // = "171C3835ABF08F842D8215E7F5C4BEB2";
  static const uint8_t binary_fingerprint[16]; // = {0x17,0x1C,0x38,0x35,0xAB,0xF0,0x8F,0x84,0x2D,0x82,0x15,0xE7,0xF5,0xC4,0xBE,0xB2};


  virtual ~XSMBService_CreateFile_presult() throw();
  LinuxFileResponse* success;
  LinuxFileException linuxFileException;

  _XSMBService_CreateFile_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_CreateFile_presult& obj);
};

typedef struct _XSMBService_DeleteFile_args__isset {
  _XSMBService_DeleteFile_args__isset() : filePath(false) {}
  bool filePath :1;
} _XSMBService_DeleteFile_args__isset;

class XSMBService_DeleteFile_args {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  XSMBService_DeleteFile_args(const XSMBService_DeleteFile_args&);
  XSMBService_DeleteFile_args& operator=(const XSMBService_DeleteFile_args&);
  XSMBService_DeleteFile_args() : filePath() {
  }

  virtual ~XSMBService_DeleteFile_args() throw();
  std::string filePath;

  _XSMBService_DeleteFile_args__isset __isset;

  void __set_filePath(const std::string& val);

  bool operator == (const XSMBService_DeleteFile_args & rhs) const
  {
    if (!(filePath == rhs.filePath))
      return false;
    return true;
  }
  bool operator != (const XSMBService_DeleteFile_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_DeleteFile_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_DeleteFile_args& obj);
};


class XSMBService_DeleteFile_pargs {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};


  virtual ~XSMBService_DeleteFile_pargs() throw();
  const std::string* filePath;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_DeleteFile_pargs& obj);
};

typedef struct _XSMBService_DeleteFile_result__isset {
  _XSMBService_DeleteFile_result__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_DeleteFile_result__isset;

class XSMBService_DeleteFile_result {
 public:

  static const char* ascii_fingerprint; // = "171C3835ABF08F842D8215E7F5C4BEB2";
  static const uint8_t binary_fingerprint[16]; // = {0x17,0x1C,0x38,0x35,0xAB,0xF0,0x8F,0x84,0x2D,0x82,0x15,0xE7,0xF5,0xC4,0xBE,0xB2};

  XSMBService_DeleteFile_result(const XSMBService_DeleteFile_result&);
  XSMBService_DeleteFile_result& operator=(const XSMBService_DeleteFile_result&);
  XSMBService_DeleteFile_result() {
  }

  virtual ~XSMBService_DeleteFile_result() throw();
  LinuxFileResponse success;
  LinuxFileException linuxFileException;

  _XSMBService_DeleteFile_result__isset __isset;

  void __set_success(const LinuxFileResponse& val);

  void __set_linuxFileException(const LinuxFileException& val);

  bool operator == (const XSMBService_DeleteFile_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(linuxFileException == rhs.linuxFileException))
      return false;
    return true;
  }
  bool operator != (const XSMBService_DeleteFile_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_DeleteFile_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_DeleteFile_result& obj);
};

typedef struct _XSMBService_DeleteFile_presult__isset {
  _XSMBService_DeleteFile_presult__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_DeleteFile_presult__isset;

class XSMBService_DeleteFile_presult {
 public:

  static const char* ascii_fingerprint; // = "171C3835ABF08F842D8215E7F5C4BEB2";
  static const uint8_t binary_fingerprint[16]; // = {0x17,0x1C,0x38,0x35,0xAB,0xF0,0x8F,0x84,0x2D,0x82,0x15,0xE7,0xF5,0xC4,0xBE,0xB2};


  virtual ~XSMBService_DeleteFile_presult() throw();
  LinuxFileResponse* success;
  LinuxFileException linuxFileException;

  _XSMBService_DeleteFile_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_DeleteFile_presult& obj);
};

typedef struct _XSMBService_ReadFile_args__isset {
  _XSMBService_ReadFile_args__isset() : filePath(false), offset(false), count(false) {}
  bool filePath :1;
  bool offset :1;
  bool count :1;
} _XSMBService_ReadFile_args__isset;

class XSMBService_ReadFile_args {
 public:

  static const char* ascii_fingerprint; // = "A4B0EC7D8E2C91B205150169F789382C";
  static const uint8_t binary_fingerprint[16]; // = {0xA4,0xB0,0xEC,0x7D,0x8E,0x2C,0x91,0xB2,0x05,0x15,0x01,0x69,0xF7,0x89,0x38,0x2C};

  XSMBService_ReadFile_args(const XSMBService_ReadFile_args&);
  XSMBService_ReadFile_args& operator=(const XSMBService_ReadFile_args&);
  XSMBService_ReadFile_args() : filePath(), offset(0), count(0) {
  }

  virtual ~XSMBService_ReadFile_args() throw();
  std::string filePath;
  int64_t offset;
  int64_t count;

  _XSMBService_ReadFile_args__isset __isset;

  void __set_filePath(const std::string& val);

  void __set_offset(const int64_t val);

  void __set_count(const int64_t val);

  bool operator == (const XSMBService_ReadFile_args & rhs) const
  {
    if (!(filePath == rhs.filePath))
      return false;
    if (!(offset == rhs.offset))
      return false;
    if (!(count == rhs.count))
      return false;
    return true;
  }
  bool operator != (const XSMBService_ReadFile_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_ReadFile_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_ReadFile_args& obj);
};


class XSMBService_ReadFile_pargs {
 public:

  static const char* ascii_fingerprint; // = "A4B0EC7D8E2C91B205150169F789382C";
  static const uint8_t binary_fingerprint[16]; // = {0xA4,0xB0,0xEC,0x7D,0x8E,0x2C,0x91,0xB2,0x05,0x15,0x01,0x69,0xF7,0x89,0x38,0x2C};


  virtual ~XSMBService_ReadFile_pargs() throw();
  const std::string* filePath;
  const int64_t* offset;
  const int64_t* count;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_ReadFile_pargs& obj);
};

typedef struct _XSMBService_ReadFile_result__isset {
  _XSMBService_ReadFile_result__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_ReadFile_result__isset;

class XSMBService_ReadFile_result {
 public:

  static const char* ascii_fingerprint; // = "171C3835ABF08F842D8215E7F5C4BEB2";
  static const uint8_t binary_fingerprint[16]; // = {0x17,0x1C,0x38,0x35,0xAB,0xF0,0x8F,0x84,0x2D,0x82,0x15,0xE7,0xF5,0xC4,0xBE,0xB2};

  XSMBService_ReadFile_result(const XSMBService_ReadFile_result&);
  XSMBService_ReadFile_result& operator=(const XSMBService_ReadFile_result&);
  XSMBService_ReadFile_result() {
  }

  virtual ~XSMBService_ReadFile_result() throw();
  LinuxFileResponse success;
  LinuxFileException linuxFileException;

  _XSMBService_ReadFile_result__isset __isset;

  void __set_success(const LinuxFileResponse& val);

  void __set_linuxFileException(const LinuxFileException& val);

  bool operator == (const XSMBService_ReadFile_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(linuxFileException == rhs.linuxFileException))
      return false;
    return true;
  }
  bool operator != (const XSMBService_ReadFile_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_ReadFile_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_ReadFile_result& obj);
};

typedef struct _XSMBService_ReadFile_presult__isset {
  _XSMBService_ReadFile_presult__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_ReadFile_presult__isset;

class XSMBService_ReadFile_presult {
 public:

  static const char* ascii_fingerprint; // = "171C3835ABF08F842D8215E7F5C4BEB2";
  static const uint8_t binary_fingerprint[16]; // = {0x17,0x1C,0x38,0x35,0xAB,0xF0,0x8F,0x84,0x2D,0x82,0x15,0xE7,0xF5,0xC4,0xBE,0xB2};


  virtual ~XSMBService_ReadFile_presult() throw();
  LinuxFileResponse* success;
  LinuxFileException linuxFileException;

  _XSMBService_ReadFile_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_ReadFile_presult& obj);
};

typedef struct _XSMBService_WriteFile_args__isset {
  _XSMBService_WriteFile_args__isset() : filePath(false), offset(false), buffer(false), count(false) {}
  bool filePath :1;
  bool offset :1;
  bool buffer :1;
  bool count :1;
} _XSMBService_WriteFile_args__isset;

class XSMBService_WriteFile_args {
 public:

  static const char* ascii_fingerprint; // = "35DBF03AFE6CFC38FE634CDAF038307C";
  static const uint8_t binary_fingerprint[16]; // = {0x35,0xDB,0xF0,0x3A,0xFE,0x6C,0xFC,0x38,0xFE,0x63,0x4C,0xDA,0xF0,0x38,0x30,0x7C};

  XSMBService_WriteFile_args(const XSMBService_WriteFile_args&);
  XSMBService_WriteFile_args& operator=(const XSMBService_WriteFile_args&);
  XSMBService_WriteFile_args() : filePath(), offset(0), buffer(), count(0) {
  }

  virtual ~XSMBService_WriteFile_args() throw();
  std::string filePath;
  int64_t offset;
  std::string buffer;
  int64_t count;

  _XSMBService_WriteFile_args__isset __isset;

  void __set_filePath(const std::string& val);

  void __set_offset(const int64_t val);

  void __set_buffer(const std::string& val);

  void __set_count(const int64_t val);

  bool operator == (const XSMBService_WriteFile_args & rhs) const
  {
    if (!(filePath == rhs.filePath))
      return false;
    if (!(offset == rhs.offset))
      return false;
    if (!(buffer == rhs.buffer))
      return false;
    if (!(count == rhs.count))
      return false;
    return true;
  }
  bool operator != (const XSMBService_WriteFile_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_WriteFile_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_WriteFile_args& obj);
};


class XSMBService_WriteFile_pargs {
 public:

  static const char* ascii_fingerprint; // = "35DBF03AFE6CFC38FE634CDAF038307C";
  static const uint8_t binary_fingerprint[16]; // = {0x35,0xDB,0xF0,0x3A,0xFE,0x6C,0xFC,0x38,0xFE,0x63,0x4C,0xDA,0xF0,0x38,0x30,0x7C};


  virtual ~XSMBService_WriteFile_pargs() throw();
  const std::string* filePath;
  const int64_t* offset;
  const std::string* buffer;
  const int64_t* count;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_WriteFile_pargs& obj);
};

typedef struct _XSMBService_WriteFile_result__isset {
  _XSMBService_WriteFile_result__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_WriteFile_result__isset;

class XSMBService_WriteFile_result {
 public:

  static const char* ascii_fingerprint; // = "171C3835ABF08F842D8215E7F5C4BEB2";
  static const uint8_t binary_fingerprint[16]; // = {0x17,0x1C,0x38,0x35,0xAB,0xF0,0x8F,0x84,0x2D,0x82,0x15,0xE7,0xF5,0xC4,0xBE,0xB2};

  XSMBService_WriteFile_result(const XSMBService_WriteFile_result&);
  XSMBService_WriteFile_result& operator=(const XSMBService_WriteFile_result&);
  XSMBService_WriteFile_result() {
  }

  virtual ~XSMBService_WriteFile_result() throw();
  LinuxFileResponse success;
  LinuxFileException linuxFileException;

  _XSMBService_WriteFile_result__isset __isset;

  void __set_success(const LinuxFileResponse& val);

  void __set_linuxFileException(const LinuxFileException& val);

  bool operator == (const XSMBService_WriteFile_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(linuxFileException == rhs.linuxFileException))
      return false;
    return true;
  }
  bool operator != (const XSMBService_WriteFile_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_WriteFile_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_WriteFile_result& obj);
};

typedef struct _XSMBService_WriteFile_presult__isset {
  _XSMBService_WriteFile_presult__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_WriteFile_presult__isset;

class XSMBService_WriteFile_presult {
 public:

  static const char* ascii_fingerprint; // = "171C3835ABF08F842D8215E7F5C4BEB2";
  static const uint8_t binary_fingerprint[16]; // = {0x17,0x1C,0x38,0x35,0xAB,0xF0,0x8F,0x84,0x2D,0x82,0x15,0xE7,0xF5,0xC4,0xBE,0xB2};


  virtual ~XSMBService_WriteFile_presult() throw();
  LinuxFileResponse* success;
  LinuxFileException linuxFileException;

  _XSMBService_WriteFile_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_WriteFile_presult& obj);
};

typedef struct _XSMBService_ListFiles_args__isset {
  _XSMBService_ListFiles_args__isset() : dirPath(false), isRecursive(false) {}
  bool dirPath :1;
  bool isRecursive :1;
} _XSMBService_ListFiles_args__isset;

class XSMBService_ListFiles_args {
 public:

  static const char* ascii_fingerprint; // = "7D61C9AA00102AB4D8F72A1DA58297DC";
  static const uint8_t binary_fingerprint[16]; // = {0x7D,0x61,0xC9,0xAA,0x00,0x10,0x2A,0xB4,0xD8,0xF7,0x2A,0x1D,0xA5,0x82,0x97,0xDC};

  XSMBService_ListFiles_args(const XSMBService_ListFiles_args&);
  XSMBService_ListFiles_args& operator=(const XSMBService_ListFiles_args&);
  XSMBService_ListFiles_args() : dirPath(), isRecursive(0) {
  }

  virtual ~XSMBService_ListFiles_args() throw();
  std::string dirPath;
  bool isRecursive;

  _XSMBService_ListFiles_args__isset __isset;

  void __set_dirPath(const std::string& val);

  void __set_isRecursive(const bool val);

  bool operator == (const XSMBService_ListFiles_args & rhs) const
  {
    if (!(dirPath == rhs.dirPath))
      return false;
    if (!(isRecursive == rhs.isRecursive))
      return false;
    return true;
  }
  bool operator != (const XSMBService_ListFiles_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_ListFiles_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_ListFiles_args& obj);
};


class XSMBService_ListFiles_pargs {
 public:

  static const char* ascii_fingerprint; // = "7D61C9AA00102AB4D8F72A1DA58297DC";
  static const uint8_t binary_fingerprint[16]; // = {0x7D,0x61,0xC9,0xAA,0x00,0x10,0x2A,0xB4,0xD8,0xF7,0x2A,0x1D,0xA5,0x82,0x97,0xDC};


  virtual ~XSMBService_ListFiles_pargs() throw();
  const std::string* dirPath;
  const bool* isRecursive;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_ListFiles_pargs& obj);
};

typedef struct _XSMBService_ListFiles_result__isset {
  _XSMBService_ListFiles_result__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_ListFiles_result__isset;

class XSMBService_ListFiles_result {
 public:

  static const char* ascii_fingerprint; // = "171C3835ABF08F842D8215E7F5C4BEB2";
  static const uint8_t binary_fingerprint[16]; // = {0x17,0x1C,0x38,0x35,0xAB,0xF0,0x8F,0x84,0x2D,0x82,0x15,0xE7,0xF5,0xC4,0xBE,0xB2};

  XSMBService_ListFiles_result(const XSMBService_ListFiles_result&);
  XSMBService_ListFiles_result& operator=(const XSMBService_ListFiles_result&);
  XSMBService_ListFiles_result() {
  }

  virtual ~XSMBService_ListFiles_result() throw();
  LinuxFileResponse success;
  LinuxFileException linuxFileException;

  _XSMBService_ListFiles_result__isset __isset;

  void __set_success(const LinuxFileResponse& val);

  void __set_linuxFileException(const LinuxFileException& val);

  bool operator == (const XSMBService_ListFiles_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(linuxFileException == rhs.linuxFileException))
      return false;
    return true;
  }
  bool operator != (const XSMBService_ListFiles_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_ListFiles_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_ListFiles_result& obj);
};

typedef struct _XSMBService_ListFiles_presult__isset {
  _XSMBService_ListFiles_presult__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_ListFiles_presult__isset;

class XSMBService_ListFiles_presult {
 public:

  static const char* ascii_fingerprint; // = "171C3835ABF08F842D8215E7F5C4BEB2";
  static const uint8_t binary_fingerprint[16]; // = {0x17,0x1C,0x38,0x35,0xAB,0xF0,0x8F,0x84,0x2D,0x82,0x15,0xE7,0xF5,0xC4,0xBE,0xB2};


  virtual ~XSMBService_ListFiles_presult() throw();
  LinuxFileResponse* success;
  LinuxFileException linuxFileException;

  _XSMBService_ListFiles_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_ListFiles_presult& obj);
};

typedef struct _XSMBService_GetFileLength_args__isset {
  _XSMBService_GetFileLength_args__isset() : filePath(false) {}
  bool filePath :1;
} _XSMBService_GetFileLength_args__isset;

class XSMBService_GetFileLength_args {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  XSMBService_GetFileLength_args(const XSMBService_GetFileLength_args&);
  XSMBService_GetFileLength_args& operator=(const XSMBService_GetFileLength_args&);
  XSMBService_GetFileLength_args() : filePath() {
  }

  virtual ~XSMBService_GetFileLength_args() throw();
  std::string filePath;

  _XSMBService_GetFileLength_args__isset __isset;

  void __set_filePath(const std::string& val);

  bool operator == (const XSMBService_GetFileLength_args & rhs) const
  {
    if (!(filePath == rhs.filePath))
      return false;
    return true;
  }
  bool operator != (const XSMBService_GetFileLength_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_GetFileLength_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_GetFileLength_args& obj);
};


class XSMBService_GetFileLength_pargs {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};


  virtual ~XSMBService_GetFileLength_pargs() throw();
  const std::string* filePath;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_GetFileLength_pargs& obj);
};

typedef struct _XSMBService_GetFileLength_result__isset {
  _XSMBService_GetFileLength_result__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_GetFileLength_result__isset;

class XSMBService_GetFileLength_result {
 public:

  static const char* ascii_fingerprint; // = "171C3835ABF08F842D8215E7F5C4BEB2";
  static const uint8_t binary_fingerprint[16]; // = {0x17,0x1C,0x38,0x35,0xAB,0xF0,0x8F,0x84,0x2D,0x82,0x15,0xE7,0xF5,0xC4,0xBE,0xB2};

  XSMBService_GetFileLength_result(const XSMBService_GetFileLength_result&);
  XSMBService_GetFileLength_result& operator=(const XSMBService_GetFileLength_result&);
  XSMBService_GetFileLength_result() {
  }

  virtual ~XSMBService_GetFileLength_result() throw();
  LinuxFileResponse success;
  LinuxFileException linuxFileException;

  _XSMBService_GetFileLength_result__isset __isset;

  void __set_success(const LinuxFileResponse& val);

  void __set_linuxFileException(const LinuxFileException& val);

  bool operator == (const XSMBService_GetFileLength_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(linuxFileException == rhs.linuxFileException))
      return false;
    return true;
  }
  bool operator != (const XSMBService_GetFileLength_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_GetFileLength_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_GetFileLength_result& obj);
};

typedef struct _XSMBService_GetFileLength_presult__isset {
  _XSMBService_GetFileLength_presult__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_GetFileLength_presult__isset;

class XSMBService_GetFileLength_presult {
 public:

  static const char* ascii_fingerprint; // = "171C3835ABF08F842D8215E7F5C4BEB2";
  static const uint8_t binary_fingerprint[16]; // = {0x17,0x1C,0x38,0x35,0xAB,0xF0,0x8F,0x84,0x2D,0x82,0x15,0xE7,0xF5,0xC4,0xBE,0xB2};


  virtual ~XSMBService_GetFileLength_presult() throw();
  LinuxFileResponse* success;
  LinuxFileException linuxFileException;

  _XSMBService_GetFileLength_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_GetFileLength_presult& obj);
};

typedef struct _XSMBService_SetFileLength_args__isset {
  _XSMBService_SetFileLength_args__isset() : filePath(false), fileLength(false) {}
  bool filePath :1;
  bool fileLength :1;
} _XSMBService_SetFileLength_args__isset;

class XSMBService_SetFileLength_args {
 public:

  static const char* ascii_fingerprint; // = "1CCCF6FC31CFD1D61BBBB1BAF3590620";
  static const uint8_t binary_fingerprint[16]; // = {0x1C,0xCC,0xF6,0xFC,0x31,0xCF,0xD1,0xD6,0x1B,0xBB,0xB1,0xBA,0xF3,0x59,0x06,0x20};

  XSMBService_SetFileLength_args(const XSMBService_SetFileLength_args&);
  XSMBService_SetFileLength_args& operator=(const XSMBService_SetFileLength_args&);
  XSMBService_SetFileLength_args() : filePath(), fileLength(0) {
  }

  virtual ~XSMBService_SetFileLength_args() throw();
  std::string filePath;
  int64_t fileLength;

  _XSMBService_SetFileLength_args__isset __isset;

  void __set_filePath(const std::string& val);

  void __set_fileLength(const int64_t val);

  bool operator == (const XSMBService_SetFileLength_args & rhs) const
  {
    if (!(filePath == rhs.filePath))
      return false;
    if (!(fileLength == rhs.fileLength))
      return false;
    return true;
  }
  bool operator != (const XSMBService_SetFileLength_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_SetFileLength_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_SetFileLength_args& obj);
};


class XSMBService_SetFileLength_pargs {
 public:

  static const char* ascii_fingerprint; // = "1CCCF6FC31CFD1D61BBBB1BAF3590620";
  static const uint8_t binary_fingerprint[16]; // = {0x1C,0xCC,0xF6,0xFC,0x31,0xCF,0xD1,0xD6,0x1B,0xBB,0xB1,0xBA,0xF3,0x59,0x06,0x20};


  virtual ~XSMBService_SetFileLength_pargs() throw();
  const std::string* filePath;
  const int64_t* fileLength;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_SetFileLength_pargs& obj);
};

typedef struct _XSMBService_SetFileLength_result__isset {
  _XSMBService_SetFileLength_result__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_SetFileLength_result__isset;

class XSMBService_SetFileLength_result {
 public:

  static const char* ascii_fingerprint; // = "171C3835ABF08F842D8215E7F5C4BEB2";
  static const uint8_t binary_fingerprint[16]; // = {0x17,0x1C,0x38,0x35,0xAB,0xF0,0x8F,0x84,0x2D,0x82,0x15,0xE7,0xF5,0xC4,0xBE,0xB2};

  XSMBService_SetFileLength_result(const XSMBService_SetFileLength_result&);
  XSMBService_SetFileLength_result& operator=(const XSMBService_SetFileLength_result&);
  XSMBService_SetFileLength_result() {
  }

  virtual ~XSMBService_SetFileLength_result() throw();
  LinuxFileResponse success;
  LinuxFileException linuxFileException;

  _XSMBService_SetFileLength_result__isset __isset;

  void __set_success(const LinuxFileResponse& val);

  void __set_linuxFileException(const LinuxFileException& val);

  bool operator == (const XSMBService_SetFileLength_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(linuxFileException == rhs.linuxFileException))
      return false;
    return true;
  }
  bool operator != (const XSMBService_SetFileLength_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_SetFileLength_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_SetFileLength_result& obj);
};

typedef struct _XSMBService_SetFileLength_presult__isset {
  _XSMBService_SetFileLength_presult__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_SetFileLength_presult__isset;

class XSMBService_SetFileLength_presult {
 public:

  static const char* ascii_fingerprint; // = "171C3835ABF08F842D8215E7F5C4BEB2";
  static const uint8_t binary_fingerprint[16]; // = {0x17,0x1C,0x38,0x35,0xAB,0xF0,0x8F,0x84,0x2D,0x82,0x15,0xE7,0xF5,0xC4,0xBE,0xB2};


  virtual ~XSMBService_SetFileLength_presult() throw();
  LinuxFileResponse* success;
  LinuxFileException linuxFileException;

  _XSMBService_SetFileLength_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_SetFileLength_presult& obj);
};

typedef struct _XSMBService_OpenFileHandle_args__isset {
  _XSMBService_OpenFileHandle_args__isset() : filePath(false), fileMode(false), fileAccess(false), handleId(false) {}
  bool filePath :1;
  bool fileMode :1;
  bool fileAccess :1;
  bool handleId :1;
} _XSMBService_OpenFileHandle_args__isset;

class XSMBService_OpenFileHandle_args {
 public:

  static const char* ascii_fingerprint; // = "F3DCED03893DDD4ADA82182F994EB52E";
  static const uint8_t binary_fingerprint[16]; // = {0xF3,0xDC,0xED,0x03,0x89,0x3D,0xDD,0x4A,0xDA,0x82,0x18,0x2F,0x99,0x4E,0xB5,0x2E};

  XSMBService_OpenFileHandle_args(const XSMBService_OpenFileHandle_args&);
  XSMBService_OpenFileHandle_args& operator=(const XSMBService_OpenFileHandle_args&);
  XSMBService_OpenFileHandle_args() : filePath(), fileMode((LinuxFileMode::type)0), fileAccess((LinuxFileAccess::type)0), handleId(0) {
  }

  virtual ~XSMBService_OpenFileHandle_args() throw();
  std::string filePath;
  LinuxFileMode::type fileMode;
  LinuxFileAccess::type fileAccess;
  int32_t handleId;

  _XSMBService_OpenFileHandle_args__isset __isset;

  void __set_filePath(const std::string& val);

  void __set_fileMode(const LinuxFileMode::type val);

  void __set_fileAccess(const LinuxFileAccess::type val);

  void __set_handleId(const int32_t val);

  bool operator == (const XSMBService_OpenFileHandle_args & rhs) const
  {
    if (!(filePath == rhs.filePath))
      return false;
    if (!(fileMode == rhs.fileMode))
      return false;
    if (!(fileAccess == rhs.fileAccess))
      return false;
    if (!(handleId == rhs.handleId))
      return false;
    return true;
  }
  bool operator != (const XSMBService_OpenFileHandle_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_OpenFileHandle_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_OpenFileHandle_args& obj);
};


class XSMBService_OpenFileHandle_pargs {
 public:

  static const char* ascii_fingerprint; // = "F3DCED03893DDD4ADA82182F994EB52E";
  static const uint8_t binary_fingerprint[16]; // = {0xF3,0xDC,0xED,0x03,0x89,0x3D,0xDD,0x4A,0xDA,0x82,0x18,0x2F,0x99,0x4E,0xB5,0x2E};


  virtual ~XSMBService_OpenFileHandle_pargs() throw();
  const std::string* filePath;
  const LinuxFileMode::type* fileMode;
  const LinuxFileAccess::type* fileAccess;
  const int32_t* handleId;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_OpenFileHandle_pargs& obj);
};

typedef struct _XSMBService_OpenFileHandle_result__isset {
  _XSMBService_OpenFileHandle_result__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_OpenFileHandle_result__isset;

class XSMBService_OpenFileHandle_result {
 public:

  static const char* ascii_fingerprint; // = "171C3835ABF08F842D8215E7F5C4BEB2";
  static const uint8_t binary_fingerprint[16]; // = {0x17,0x1C,0x38,0x35,0xAB,0xF0,0x8F,0x84,0x2D,0x82,0x15,0xE7,0xF5,0xC4,0xBE,0xB2};

  XSMBService_OpenFileHandle_result(const XSMBService_OpenFileHandle_result&);
  XSMBService_OpenFileHandle_result& operator=(const XSMBService_OpenFileHandle_result&);
  XSMBService_OpenFileHandle_result() {
  }

  virtual ~XSMBService_OpenFileHandle_result() throw();
  LinuxFileResponse success;
  LinuxFileException linuxFileException;

  _XSMBService_OpenFileHandle_result__isset __isset;

  void __set_success(const LinuxFileResponse& val);

  void __set_linuxFileException(const LinuxFileException& val);

  bool operator == (const XSMBService_OpenFileHandle_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(linuxFileException == rhs.linuxFileException))
      return false;
    return true;
  }
  bool operator != (const XSMBService_OpenFileHandle_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_OpenFileHandle_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_OpenFileHandle_result& obj);
};

typedef struct _XSMBService_OpenFileHandle_presult__isset {
  _XSMBService_OpenFileHandle_presult__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_OpenFileHandle_presult__isset;

class XSMBService_OpenFileHandle_presult {
 public:

  static const char* ascii_fingerprint; // = "171C3835ABF08F842D8215E7F5C4BEB2";
  static const uint8_t binary_fingerprint[16]; // = {0x17,0x1C,0x38,0x35,0xAB,0xF0,0x8F,0x84,0x2D,0x82,0x15,0xE7,0xF5,0xC4,0xBE,0xB2};


  virtual ~XSMBService_OpenFileHandle_presult() throw();
  LinuxFileResponse* success;
  LinuxFileException linuxFileException;

  _XSMBService_OpenFileHandle_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_OpenFileHandle_presult& obj);
};

typedef struct _XSMBService_CloseFileHandle_args__isset {
  _XSMBService_CloseFileHandle_args__isset() : handleId(false) {}
  bool handleId :1;
} _XSMBService_CloseFileHandle_args__isset;

class XSMBService_CloseFileHandle_args {
 public:

  static const char* ascii_fingerprint; // = "E86CACEB22240450EDCBEFC3A83970E4";
  static const uint8_t binary_fingerprint[16]; // = {0xE8,0x6C,0xAC,0xEB,0x22,0x24,0x04,0x50,0xED,0xCB,0xEF,0xC3,0xA8,0x39,0x70,0xE4};

  XSMBService_CloseFileHandle_args(const XSMBService_CloseFileHandle_args&);
  XSMBService_CloseFileHandle_args& operator=(const XSMBService_CloseFileHandle_args&);
  XSMBService_CloseFileHandle_args() : handleId(0) {
  }

  virtual ~XSMBService_CloseFileHandle_args() throw();
  int32_t handleId;

  _XSMBService_CloseFileHandle_args__isset __isset;

  void __set_handleId(const int32_t val);

  bool operator == (const XSMBService_CloseFileHandle_args & rhs) const
  {
    if (!(handleId == rhs.handleId))
      return false;
    return true;
  }
  bool operator != (const XSMBService_CloseFileHandle_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_CloseFileHandle_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_CloseFileHandle_args& obj);
};


class XSMBService_CloseFileHandle_pargs {
 public:

  static const char* ascii_fingerprint; // = "E86CACEB22240450EDCBEFC3A83970E4";
  static const uint8_t binary_fingerprint[16]; // = {0xE8,0x6C,0xAC,0xEB,0x22,0x24,0x04,0x50,0xED,0xCB,0xEF,0xC3,0xA8,0x39,0x70,0xE4};


  virtual ~XSMBService_CloseFileHandle_pargs() throw();
  const int32_t* handleId;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_CloseFileHandle_pargs& obj);
};

typedef struct _XSMBService_CloseFileHandle_result__isset {
  _XSMBService_CloseFileHandle_result__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_CloseFileHandle_result__isset;

class XSMBService_CloseFileHandle_result {
 public:

  static const char* ascii_fingerprint; // = "171C3835ABF08F842D8215E7F5C4BEB2";
  static const uint8_t binary_fingerprint[16]; // = {0x17,0x1C,0x38,0x35,0xAB,0xF0,0x8F,0x84,0x2D,0x82,0x15,0xE7,0xF5,0xC4,0xBE,0xB2};

  XSMBService_CloseFileHandle_result(const XSMBService_CloseFileHandle_result&);
  XSMBService_CloseFileHandle_result& operator=(const XSMBService_CloseFileHandle_result&);
  XSMBService_CloseFileHandle_result() {
  }

  virtual ~XSMBService_CloseFileHandle_result() throw();
  LinuxFileResponse success;
  LinuxFileException linuxFileException;

  _XSMBService_CloseFileHandle_result__isset __isset;

  void __set_success(const LinuxFileResponse& val);

  void __set_linuxFileException(const LinuxFileException& val);

  bool operator == (const XSMBService_CloseFileHandle_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(linuxFileException == rhs.linuxFileException))
      return false;
    return true;
  }
  bool operator != (const XSMBService_CloseFileHandle_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_CloseFileHandle_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_CloseFileHandle_result& obj);
};

typedef struct _XSMBService_CloseFileHandle_presult__isset {
  _XSMBService_CloseFileHandle_presult__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_CloseFileHandle_presult__isset;

class XSMBService_CloseFileHandle_presult {
 public:

  static const char* ascii_fingerprint; // = "171C3835ABF08F842D8215E7F5C4BEB2";
  static const uint8_t binary_fingerprint[16]; // = {0x17,0x1C,0x38,0x35,0xAB,0xF0,0x8F,0x84,0x2D,0x82,0x15,0xE7,0xF5,0xC4,0xBE,0xB2};


  virtual ~XSMBService_CloseFileHandle_presult() throw();
  LinuxFileResponse* success;
  LinuxFileException linuxFileException;

  _XSMBService_CloseFileHandle_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_CloseFileHandle_presult& obj);
};

typedef struct _XSMBService_ReadFileByHandle_args__isset {
  _XSMBService_ReadFileByHandle_args__isset() : handleId(false), offset(false), count(false) {}
  bool handleId :1;
  bool offset :1;
  bool count :1;
} _XSMBService_ReadFileByHandle_args__isset;

class XSMBService_ReadFileByHandle_args {
 public:

  static const char* ascii_fingerprint; // = "1BC2A204AB4F887721511486B2DFEBC8";
  static const uint8_t binary_fingerprint[16]; // = {0x1B,0xC2,0xA2,0x04,0xAB,0x4F,0x88,0x77,0x21,0x51,0x14,0x86,0xB2,0xDF,0xEB,0xC8};

  XSMBService_ReadFileByHandle_args(const XSMBService_ReadFileByHandle_args&);
  XSMBService_ReadFileByHandle_args& operator=(const XSMBService_ReadFileByHandle_args&);
  XSMBService_ReadFileByHandle_args() : handleId(0), offset(0), count(0) {
  }

  virtual ~XSMBService_ReadFileByHandle_args() throw();
  int32_t handleId;
  int64_t offset;
  int64_t count;

  _XSMBService_ReadFileByHandle_args__isset __isset;

  void __set_handleId(const int32_t val);

  void __set_offset(const int64_t val);

  void __set_count(const int64_t val);

  bool operator == (const XSMBService_ReadFileByHandle_args & rhs) const
  {
    if (!(handleId == rhs.handleId))
      return false;
    if (!(offset == rhs.offset))
      return false;
    if (!(count == rhs.count))
      return false;
    return true;
  }
  bool operator != (const XSMBService_ReadFileByHandle_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_ReadFileByHandle_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_ReadFileByHandle_args& obj);
};


class XSMBService_ReadFileByHandle_pargs {
 public:

  static const char* ascii_fingerprint; // = "1BC2A204AB4F887721511486B2DFEBC8";
  static const uint8_t binary_fingerprint[16]; // = {0x1B,0xC2,0xA2,0x04,0xAB,0x4F,0x88,0x77,0x21,0x51,0x14,0x86,0xB2,0xDF,0xEB,0xC8};


  virtual ~XSMBService_ReadFileByHandle_pargs() throw();
  const int32_t* handleId;
  const int64_t* offset;
  const int64_t* count;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_ReadFileByHandle_pargs& obj);
};

typedef struct _XSMBService_ReadFileByHandle_result__isset {
  _XSMBService_ReadFileByHandle_result__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_ReadFileByHandle_result__isset;

class XSMBService_ReadFileByHandle_result {
 public:

  static const char* ascii_fingerprint; // = "171C3835ABF08F842D8215E7F5C4BEB2";
  static const uint8_t binary_fingerprint[16]; // = {0x17,0x1C,0x38,0x35,0xAB,0xF0,0x8F,0x84,0x2D,0x82,0x15,0xE7,0xF5,0xC4,0xBE,0xB2};

  XSMBService_ReadFileByHandle_result(const XSMBService_ReadFileByHandle_result&);
  XSMBService_ReadFileByHandle_result& operator=(const XSMBService_ReadFileByHandle_result&);
  XSMBService_ReadFileByHandle_result() {
  }

  virtual ~XSMBService_ReadFileByHandle_result() throw();
  LinuxFileResponse success;
  LinuxFileException linuxFileException;

  _XSMBService_ReadFileByHandle_result__isset __isset;

  void __set_success(const LinuxFileResponse& val);

  void __set_linuxFileException(const LinuxFileException& val);

  bool operator == (const XSMBService_ReadFileByHandle_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(linuxFileException == rhs.linuxFileException))
      return false;
    return true;
  }
  bool operator != (const XSMBService_ReadFileByHandle_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_ReadFileByHandle_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_ReadFileByHandle_result& obj);
};

typedef struct _XSMBService_ReadFileByHandle_presult__isset {
  _XSMBService_ReadFileByHandle_presult__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_ReadFileByHandle_presult__isset;

class XSMBService_ReadFileByHandle_presult {
 public:

  static const char* ascii_fingerprint; // = "171C3835ABF08F842D8215E7F5C4BEB2";
  static const uint8_t binary_fingerprint[16]; // = {0x17,0x1C,0x38,0x35,0xAB,0xF0,0x8F,0x84,0x2D,0x82,0x15,0xE7,0xF5,0xC4,0xBE,0xB2};


  virtual ~XSMBService_ReadFileByHandle_presult() throw();
  LinuxFileResponse* success;
  LinuxFileException linuxFileException;

  _XSMBService_ReadFileByHandle_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_ReadFileByHandle_presult& obj);
};

typedef struct _XSMBService_WriteFileByHandle_args__isset {
  _XSMBService_WriteFileByHandle_args__isset() : handleId(false), offset(false), buffer(false), count(false) {}
  bool handleId :1;
  bool offset :1;
  bool buffer :1;
  bool count :1;
} _XSMBService_WriteFileByHandle_args__isset;

class XSMBService_WriteFileByHandle_args {
 public:

  static const char* ascii_fingerprint; // = "88C6C8491531BE020F1333360573FCC9";
  static const uint8_t binary_fingerprint[16]; // = {0x88,0xC6,0xC8,0x49,0x15,0x31,0xBE,0x02,0x0F,0x13,0x33,0x36,0x05,0x73,0xFC,0xC9};

  XSMBService_WriteFileByHandle_args(const XSMBService_WriteFileByHandle_args&);
  XSMBService_WriteFileByHandle_args& operator=(const XSMBService_WriteFileByHandle_args&);
  XSMBService_WriteFileByHandle_args() : handleId(0), offset(0), buffer(), count(0) {
  }

  virtual ~XSMBService_WriteFileByHandle_args() throw();
  int32_t handleId;
  int64_t offset;
  std::string buffer;
  int64_t count;

  _XSMBService_WriteFileByHandle_args__isset __isset;

  void __set_handleId(const int32_t val);

  void __set_offset(const int64_t val);

  void __set_buffer(const std::string& val);

  void __set_count(const int64_t val);

  bool operator == (const XSMBService_WriteFileByHandle_args & rhs) const
  {
    if (!(handleId == rhs.handleId))
      return false;
    if (!(offset == rhs.offset))
      return false;
    if (!(buffer == rhs.buffer))
      return false;
    if (!(count == rhs.count))
      return false;
    return true;
  }
  bool operator != (const XSMBService_WriteFileByHandle_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_WriteFileByHandle_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_WriteFileByHandle_args& obj);
};


class XSMBService_WriteFileByHandle_pargs {
 public:

  static const char* ascii_fingerprint; // = "88C6C8491531BE020F1333360573FCC9";
  static const uint8_t binary_fingerprint[16]; // = {0x88,0xC6,0xC8,0x49,0x15,0x31,0xBE,0x02,0x0F,0x13,0x33,0x36,0x05,0x73,0xFC,0xC9};


  virtual ~XSMBService_WriteFileByHandle_pargs() throw();
  const int32_t* handleId;
  const int64_t* offset;
  const std::string* buffer;
  const int64_t* count;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_WriteFileByHandle_pargs& obj);
};

typedef struct _XSMBService_WriteFileByHandle_result__isset {
  _XSMBService_WriteFileByHandle_result__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_WriteFileByHandle_result__isset;

class XSMBService_WriteFileByHandle_result {
 public:

  static const char* ascii_fingerprint; // = "171C3835ABF08F842D8215E7F5C4BEB2";
  static const uint8_t binary_fingerprint[16]; // = {0x17,0x1C,0x38,0x35,0xAB,0xF0,0x8F,0x84,0x2D,0x82,0x15,0xE7,0xF5,0xC4,0xBE,0xB2};

  XSMBService_WriteFileByHandle_result(const XSMBService_WriteFileByHandle_result&);
  XSMBService_WriteFileByHandle_result& operator=(const XSMBService_WriteFileByHandle_result&);
  XSMBService_WriteFileByHandle_result() {
  }

  virtual ~XSMBService_WriteFileByHandle_result() throw();
  LinuxFileResponse success;
  LinuxFileException linuxFileException;

  _XSMBService_WriteFileByHandle_result__isset __isset;

  void __set_success(const LinuxFileResponse& val);

  void __set_linuxFileException(const LinuxFileException& val);

  bool operator == (const XSMBService_WriteFileByHandle_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(linuxFileException == rhs.linuxFileException))
      return false;
    return true;
  }
  bool operator != (const XSMBService_WriteFileByHandle_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_WriteFileByHandle_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_WriteFileByHandle_result& obj);
};

typedef struct _XSMBService_WriteFileByHandle_presult__isset {
  _XSMBService_WriteFileByHandle_presult__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_WriteFileByHandle_presult__isset;

class XSMBService_WriteFileByHandle_presult {
 public:

  static const char* ascii_fingerprint; // = "171C3835ABF08F842D8215E7F5C4BEB2";
  static const uint8_t binary_fingerprint[16]; // = {0x17,0x1C,0x38,0x35,0xAB,0xF0,0x8F,0x84,0x2D,0x82,0x15,0xE7,0xF5,0xC4,0xBE,0xB2};


  virtual ~XSMBService_WriteFileByHandle_presult() throw();
  LinuxFileResponse* success;
  LinuxFileException linuxFileException;

  _XSMBService_WriteFileByHandle_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_WriteFileByHandle_presult& obj);
};

typedef struct _XSMBService_MoveFile_args__isset {
  _XSMBService_MoveFile_args__isset() : sourcePath(false), destinationPath(false), overwriteIfExists(false), fileCopyAllowed(false) {}
  bool sourcePath :1;
  bool destinationPath :1;
  bool overwriteIfExists :1;
  bool fileCopyAllowed :1;
} _XSMBService_MoveFile_args__isset;

class XSMBService_MoveFile_args {
 public:

  static const char* ascii_fingerprint; // = "205A83737DD361E88B396E77A0B7A5BD";
  static const uint8_t binary_fingerprint[16]; // = {0x20,0x5A,0x83,0x73,0x7D,0xD3,0x61,0xE8,0x8B,0x39,0x6E,0x77,0xA0,0xB7,0xA5,0xBD};

  XSMBService_MoveFile_args(const XSMBService_MoveFile_args&);
  XSMBService_MoveFile_args& operator=(const XSMBService_MoveFile_args&);
  XSMBService_MoveFile_args() : sourcePath(), destinationPath(), overwriteIfExists(0), fileCopyAllowed(0) {
  }

  virtual ~XSMBService_MoveFile_args() throw();
  std::string sourcePath;
  std::string destinationPath;
  bool overwriteIfExists;
  bool fileCopyAllowed;

  _XSMBService_MoveFile_args__isset __isset;

  void __set_sourcePath(const std::string& val);

  void __set_destinationPath(const std::string& val);

  void __set_overwriteIfExists(const bool val);

  void __set_fileCopyAllowed(const bool val);

  bool operator == (const XSMBService_MoveFile_args & rhs) const
  {
    if (!(sourcePath == rhs.sourcePath))
      return false;
    if (!(destinationPath == rhs.destinationPath))
      return false;
    if (!(overwriteIfExists == rhs.overwriteIfExists))
      return false;
    if (!(fileCopyAllowed == rhs.fileCopyAllowed))
      return false;
    return true;
  }
  bool operator != (const XSMBService_MoveFile_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_MoveFile_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_MoveFile_args& obj);
};


class XSMBService_MoveFile_pargs {
 public:

  static const char* ascii_fingerprint; // = "205A83737DD361E88B396E77A0B7A5BD";
  static const uint8_t binary_fingerprint[16]; // = {0x20,0x5A,0x83,0x73,0x7D,0xD3,0x61,0xE8,0x8B,0x39,0x6E,0x77,0xA0,0xB7,0xA5,0xBD};


  virtual ~XSMBService_MoveFile_pargs() throw();
  const std::string* sourcePath;
  const std::string* destinationPath;
  const bool* overwriteIfExists;
  const bool* fileCopyAllowed;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_MoveFile_pargs& obj);
};

typedef struct _XSMBService_MoveFile_result__isset {
  _XSMBService_MoveFile_result__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_MoveFile_result__isset;

class XSMBService_MoveFile_result {
 public:

  static const char* ascii_fingerprint; // = "171C3835ABF08F842D8215E7F5C4BEB2";
  static const uint8_t binary_fingerprint[16]; // = {0x17,0x1C,0x38,0x35,0xAB,0xF0,0x8F,0x84,0x2D,0x82,0x15,0xE7,0xF5,0xC4,0xBE,0xB2};

  XSMBService_MoveFile_result(const XSMBService_MoveFile_result&);
  XSMBService_MoveFile_result& operator=(const XSMBService_MoveFile_result&);
  XSMBService_MoveFile_result() {
  }

  virtual ~XSMBService_MoveFile_result() throw();
  LinuxFileResponse success;
  LinuxFileException linuxFileException;

  _XSMBService_MoveFile_result__isset __isset;

  void __set_success(const LinuxFileResponse& val);

  void __set_linuxFileException(const LinuxFileException& val);

  bool operator == (const XSMBService_MoveFile_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(linuxFileException == rhs.linuxFileException))
      return false;
    return true;
  }
  bool operator != (const XSMBService_MoveFile_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_MoveFile_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_MoveFile_result& obj);
};

typedef struct _XSMBService_MoveFile_presult__isset {
  _XSMBService_MoveFile_presult__isset() : success(false), linuxFileException(false) {}
  bool success :1;
  bool linuxFileException :1;
} _XSMBService_MoveFile_presult__isset;

class XSMBService_MoveFile_presult {
 public:

  static const char* ascii_fingerprint; // = "171C3835ABF08F842D8215E7F5C4BEB2";
  static const uint8_t binary_fingerprint[16]; // = {0x17,0x1C,0x38,0x35,0xAB,0xF0,0x8F,0x84,0x2D,0x82,0x15,0xE7,0xF5,0xC4,0xBE,0xB2};


  virtual ~XSMBService_MoveFile_presult() throw();
  LinuxFileResponse* success;
  LinuxFileException linuxFileException;

  _XSMBService_MoveFile_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const XSMBService_MoveFile_presult& obj);
};

class XSMBServiceClient : virtual public XSMBServiceIf {
 public:
  XSMBServiceClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  XSMBServiceClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void PathExists(LinuxFileResponse& _return, const std::string& path);
  void send_PathExists(const std::string& path);
  void recv_PathExists(LinuxFileResponse& _return);
  void CreateDirectory(LinuxFileResponse& _return, const std::string& dirPath);
  void send_CreateDirectory(const std::string& dirPath);
  void recv_CreateDirectory(LinuxFileResponse& _return);
  void CopyFile(LinuxFileResponse& _return, const std::string& sourcePath, const std::string& destinationPath, const bool overwriteIfExists);
  void send_CopyFile(const std::string& sourcePath, const std::string& destinationPath, const bool overwriteIfExists);
  void recv_CopyFile(LinuxFileResponse& _return);
  void DeleteDirectory(LinuxFileResponse& _return, const std::string& dirPath, const bool isRecursive);
  void send_DeleteDirectory(const std::string& dirPath, const bool isRecursive);
  void recv_DeleteDirectory(LinuxFileResponse& _return);
  void CreateFile(LinuxFileResponse& _return, const std::string& filePath, const int64_t fileSize, const bool noBuffering);
  void send_CreateFile(const std::string& filePath, const int64_t fileSize, const bool noBuffering);
  void recv_CreateFile(LinuxFileResponse& _return);
  void DeleteFile(LinuxFileResponse& _return, const std::string& filePath);
  void send_DeleteFile(const std::string& filePath);
  void recv_DeleteFile(LinuxFileResponse& _return);
  void ReadFile(LinuxFileResponse& _return, const std::string& filePath, const int64_t offset, const int64_t count);
  void send_ReadFile(const std::string& filePath, const int64_t offset, const int64_t count);
  void recv_ReadFile(LinuxFileResponse& _return);
  void WriteFile(LinuxFileResponse& _return, const std::string& filePath, const int64_t offset, const std::string& buffer, const int64_t count);
  void send_WriteFile(const std::string& filePath, const int64_t offset, const std::string& buffer, const int64_t count);
  void recv_WriteFile(LinuxFileResponse& _return);
  void ListFiles(LinuxFileResponse& _return, const std::string& dirPath, const bool isRecursive);
  void send_ListFiles(const std::string& dirPath, const bool isRecursive);
  void recv_ListFiles(LinuxFileResponse& _return);
  void GetFileLength(LinuxFileResponse& _return, const std::string& filePath);
  void send_GetFileLength(const std::string& filePath);
  void recv_GetFileLength(LinuxFileResponse& _return);
  void SetFileLength(LinuxFileResponse& _return, const std::string& filePath, const int64_t fileLength);
  void send_SetFileLength(const std::string& filePath, const int64_t fileLength);
  void recv_SetFileLength(LinuxFileResponse& _return);
  void OpenFileHandle(LinuxFileResponse& _return, const std::string& filePath, const LinuxFileMode::type fileMode, const LinuxFileAccess::type fileAccess, const int32_t handleId);
  void send_OpenFileHandle(const std::string& filePath, const LinuxFileMode::type fileMode, const LinuxFileAccess::type fileAccess, const int32_t handleId);
  void recv_OpenFileHandle(LinuxFileResponse& _return);
  void CloseFileHandle(LinuxFileResponse& _return, const int32_t handleId);
  void send_CloseFileHandle(const int32_t handleId);
  void recv_CloseFileHandle(LinuxFileResponse& _return);
  void ReadFileByHandle(LinuxFileResponse& _return, const int32_t handleId, const int64_t offset, const int64_t count);
  void send_ReadFileByHandle(const int32_t handleId, const int64_t offset, const int64_t count);
  void recv_ReadFileByHandle(LinuxFileResponse& _return);
  void WriteFileByHandle(LinuxFileResponse& _return, const int32_t handleId, const int64_t offset, const std::string& buffer, const int64_t count);
  void send_WriteFileByHandle(const int32_t handleId, const int64_t offset, const std::string& buffer, const int64_t count);
  void recv_WriteFileByHandle(LinuxFileResponse& _return);
  void MoveFile(LinuxFileResponse& _return, const std::string& sourcePath, const std::string& destinationPath, const bool overwriteIfExists, const bool fileCopyAllowed);
  void send_MoveFile(const std::string& sourcePath, const std::string& destinationPath, const bool overwriteIfExists, const bool fileCopyAllowed);
  void recv_MoveFile(LinuxFileResponse& _return);
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class XSMBServiceProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  boost::shared_ptr<XSMBServiceIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (XSMBServiceProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_PathExists(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_CreateDirectory(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_CopyFile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_DeleteDirectory(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_CreateFile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_DeleteFile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_ReadFile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_WriteFile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_ListFiles(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_GetFileLength(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_SetFileLength(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_OpenFileHandle(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_CloseFileHandle(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_ReadFileByHandle(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_WriteFileByHandle(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_MoveFile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  XSMBServiceProcessor(boost::shared_ptr<XSMBServiceIf> iface) :
    iface_(iface) {
    processMap_["PathExists"] = &XSMBServiceProcessor::process_PathExists;
    processMap_["CreateDirectory"] = &XSMBServiceProcessor::process_CreateDirectory;
    processMap_["CopyFile"] = &XSMBServiceProcessor::process_CopyFile;
    processMap_["DeleteDirectory"] = &XSMBServiceProcessor::process_DeleteDirectory;
    processMap_["CreateFile"] = &XSMBServiceProcessor::process_CreateFile;
    processMap_["DeleteFile"] = &XSMBServiceProcessor::process_DeleteFile;
    processMap_["ReadFile"] = &XSMBServiceProcessor::process_ReadFile;
    processMap_["WriteFile"] = &XSMBServiceProcessor::process_WriteFile;
    processMap_["ListFiles"] = &XSMBServiceProcessor::process_ListFiles;
    processMap_["GetFileLength"] = &XSMBServiceProcessor::process_GetFileLength;
    processMap_["SetFileLength"] = &XSMBServiceProcessor::process_SetFileLength;
    processMap_["OpenFileHandle"] = &XSMBServiceProcessor::process_OpenFileHandle;
    processMap_["CloseFileHandle"] = &XSMBServiceProcessor::process_CloseFileHandle;
    processMap_["ReadFileByHandle"] = &XSMBServiceProcessor::process_ReadFileByHandle;
    processMap_["WriteFileByHandle"] = &XSMBServiceProcessor::process_WriteFileByHandle;
    processMap_["MoveFile"] = &XSMBServiceProcessor::process_MoveFile;
  }

  virtual ~XSMBServiceProcessor() {}
};

class XSMBServiceProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  XSMBServiceProcessorFactory(const ::boost::shared_ptr< XSMBServiceIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::boost::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::boost::shared_ptr< XSMBServiceIfFactory > handlerFactory_;
};

class XSMBServiceMultiface : virtual public XSMBServiceIf {
 public:
  XSMBServiceMultiface(std::vector<boost::shared_ptr<XSMBServiceIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~XSMBServiceMultiface() {}
 protected:
  std::vector<boost::shared_ptr<XSMBServiceIf> > ifaces_;
  XSMBServiceMultiface() {}
  void add(boost::shared_ptr<XSMBServiceIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void PathExists(LinuxFileResponse& _return, const std::string& path) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->PathExists(_return, path);
    }
    ifaces_[i]->PathExists(_return, path);
    return;
  }

  void CreateDirectory(LinuxFileResponse& _return, const std::string& dirPath) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->CreateDirectory(_return, dirPath);
    }
    ifaces_[i]->CreateDirectory(_return, dirPath);
    return;
  }

  void CopyFile(LinuxFileResponse& _return, const std::string& sourcePath, const std::string& destinationPath, const bool overwriteIfExists) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->CopyFile(_return, sourcePath, destinationPath, overwriteIfExists);
    }
    ifaces_[i]->CopyFile(_return, sourcePath, destinationPath, overwriteIfExists);
    return;
  }

  void DeleteDirectory(LinuxFileResponse& _return, const std::string& dirPath, const bool isRecursive) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->DeleteDirectory(_return, dirPath, isRecursive);
    }
    ifaces_[i]->DeleteDirectory(_return, dirPath, isRecursive);
    return;
  }

  void CreateFile(LinuxFileResponse& _return, const std::string& filePath, const int64_t fileSize, const bool noBuffering) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->CreateFile(_return, filePath, fileSize, noBuffering);
    }
    ifaces_[i]->CreateFile(_return, filePath, fileSize, noBuffering);
    return;
  }

  void DeleteFile(LinuxFileResponse& _return, const std::string& filePath) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->DeleteFile(_return, filePath);
    }
    ifaces_[i]->DeleteFile(_return, filePath);
    return;
  }

  void ReadFile(LinuxFileResponse& _return, const std::string& filePath, const int64_t offset, const int64_t count) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->ReadFile(_return, filePath, offset, count);
    }
    ifaces_[i]->ReadFile(_return, filePath, offset, count);
    return;
  }

  void WriteFile(LinuxFileResponse& _return, const std::string& filePath, const int64_t offset, const std::string& buffer, const int64_t count) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->WriteFile(_return, filePath, offset, buffer, count);
    }
    ifaces_[i]->WriteFile(_return, filePath, offset, buffer, count);
    return;
  }

  void ListFiles(LinuxFileResponse& _return, const std::string& dirPath, const bool isRecursive) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->ListFiles(_return, dirPath, isRecursive);
    }
    ifaces_[i]->ListFiles(_return, dirPath, isRecursive);
    return;
  }

  void GetFileLength(LinuxFileResponse& _return, const std::string& filePath) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->GetFileLength(_return, filePath);
    }
    ifaces_[i]->GetFileLength(_return, filePath);
    return;
  }

  void SetFileLength(LinuxFileResponse& _return, const std::string& filePath, const int64_t fileLength) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->SetFileLength(_return, filePath, fileLength);
    }
    ifaces_[i]->SetFileLength(_return, filePath, fileLength);
    return;
  }

  void OpenFileHandle(LinuxFileResponse& _return, const std::string& filePath, const LinuxFileMode::type fileMode, const LinuxFileAccess::type fileAccess, const int32_t handleId) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->OpenFileHandle(_return, filePath, fileMode, fileAccess, handleId);
    }
    ifaces_[i]->OpenFileHandle(_return, filePath, fileMode, fileAccess, handleId);
    return;
  }

  void CloseFileHandle(LinuxFileResponse& _return, const int32_t handleId) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->CloseFileHandle(_return, handleId);
    }
    ifaces_[i]->CloseFileHandle(_return, handleId);
    return;
  }

  void ReadFileByHandle(LinuxFileResponse& _return, const int32_t handleId, const int64_t offset, const int64_t count) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->ReadFileByHandle(_return, handleId, offset, count);
    }
    ifaces_[i]->ReadFileByHandle(_return, handleId, offset, count);
    return;
  }

  void WriteFileByHandle(LinuxFileResponse& _return, const int32_t handleId, const int64_t offset, const std::string& buffer, const int64_t count) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->WriteFileByHandle(_return, handleId, offset, buffer, count);
    }
    ifaces_[i]->WriteFileByHandle(_return, handleId, offset, buffer, count);
    return;
  }

  void MoveFile(LinuxFileResponse& _return, const std::string& sourcePath, const std::string& destinationPath, const bool overwriteIfExists, const bool fileCopyAllowed) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->MoveFile(_return, sourcePath, destinationPath, overwriteIfExists, fileCopyAllowed);
    }
    ifaces_[i]->MoveFile(_return, sourcePath, destinationPath, overwriteIfExists, fileCopyAllowed);
    return;
  }

};

}}} // namespace

#endif
