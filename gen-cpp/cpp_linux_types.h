/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef cpp_linux_TYPES_H
#define cpp_linux_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace azure { namespace storage { namespace cpp_linux {

struct MatchInformation {
  enum type {
    OnlyOnServer = 1,
    OnlyInKeys = 2,
    DeletedOnClient = 3,
    Match = 4
  };
};

extern const std::map<int, const char*> _MatchInformation_VALUES_TO_NAMES;

struct OperationType {
  enum type {
    MapFileShare = 0,
    UnmapFileShare = 1,
    CreateDirectory = 2,
    DeleteDirectory = 3,
    CreateFile = 4,
    DeleteFile = 5,
    ReadFile = 6,
    WriteFile = 7,
    ListFile = 8,
    GetFileLength = 9,
    SetFileLength = 10
  };
};

extern const std::map<int, const char*> _OperationType_VALUES_TO_NAMES;

class ChunkInfo;

class StreamDataLayout;

class LinuxFileException;

class LinuxFileResponse;

class GetFileLengthResponse;

typedef struct _ChunkInfo__isset {
  _ChunkInfo__isset() : OffSet(false), Length(false), Version(false), IsNullDataWritten(false), IsCorrupted(false) {}
  bool OffSet :1;
  bool Length :1;
  bool Version :1;
  bool IsNullDataWritten :1;
  bool IsCorrupted :1;
} _ChunkInfo__isset;

class ChunkInfo {
 public:

  static const char* ascii_fingerprint; // = "2D1F7C9D7EF060322343EC2AB2852351";
  static const uint8_t binary_fingerprint[16]; // = {0x2D,0x1F,0x7C,0x9D,0x7E,0xF0,0x60,0x32,0x23,0x43,0xEC,0x2A,0xB2,0x85,0x23,0x51};

  ChunkInfo(const ChunkInfo&);
  ChunkInfo& operator=(const ChunkInfo&);
  ChunkInfo() : OffSet(0), Length(0), Version(0), IsNullDataWritten(0), IsCorrupted(0) {
  }

  virtual ~ChunkInfo() throw();
  int64_t OffSet;
  int32_t Length;
  int8_t Version;
  bool IsNullDataWritten;
  bool IsCorrupted;

  _ChunkInfo__isset __isset;

  void __set_OffSet(const int64_t val);

  void __set_Length(const int32_t val);

  void __set_Version(const int8_t val);

  void __set_IsNullDataWritten(const bool val);

  void __set_IsCorrupted(const bool val);

  bool operator == (const ChunkInfo & rhs) const
  {
    if (!(OffSet == rhs.OffSet))
      return false;
    if (!(Length == rhs.Length))
      return false;
    if (!(Version == rhs.Version))
      return false;
    if (!(IsNullDataWritten == rhs.IsNullDataWritten))
      return false;
    if (!(IsCorrupted == rhs.IsCorrupted))
      return false;
    return true;
  }
  bool operator != (const ChunkInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ChunkInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ChunkInfo& obj);
};

void swap(ChunkInfo &a, ChunkInfo &b);

typedef struct _StreamDataLayout__isset {
  _StreamDataLayout__isset() : Chunks(false), Length(false) {}
  bool Chunks :1;
  bool Length :1;
} _StreamDataLayout__isset;

class StreamDataLayout {
 public:

  static const char* ascii_fingerprint; // = "80E1C3D0F6200FD3585FF05B5D9711A9";
  static const uint8_t binary_fingerprint[16]; // = {0x80,0xE1,0xC3,0xD0,0xF6,0x20,0x0F,0xD3,0x58,0x5F,0xF0,0x5B,0x5D,0x97,0x11,0xA9};

  StreamDataLayout(const StreamDataLayout&);
  StreamDataLayout& operator=(const StreamDataLayout&);
  StreamDataLayout() : Length(0) {
  }

  virtual ~StreamDataLayout() throw();
  std::vector<ChunkInfo>  Chunks;
  int64_t Length;

  _StreamDataLayout__isset __isset;

  void __set_Chunks(const std::vector<ChunkInfo> & val);

  void __set_Length(const int64_t val);

  bool operator == (const StreamDataLayout & rhs) const
  {
    if (!(Chunks == rhs.Chunks))
      return false;
    if (!(Length == rhs.Length))
      return false;
    return true;
  }
  bool operator != (const StreamDataLayout &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StreamDataLayout & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const StreamDataLayout& obj);
};

void swap(StreamDataLayout &a, StreamDataLayout &b);

typedef struct _LinuxFileException__isset {
  _LinuxFileException__isset() : AdditionalInfo(false) {}
  bool AdditionalInfo :1;
} _LinuxFileException__isset;

class LinuxFileException : public ::apache::thrift::TException {
 public:

  static const char* ascii_fingerprint; // = "BDDAF3D09FC0B99327A424F4DD1D4E7A";
  static const uint8_t binary_fingerprint[16]; // = {0xBD,0xDA,0xF3,0xD0,0x9F,0xC0,0xB9,0x93,0x27,0xA4,0x24,0xF4,0xDD,0x1D,0x4E,0x7A};

  LinuxFileException(const LinuxFileException&);
  LinuxFileException& operator=(const LinuxFileException&);
  LinuxFileException() : ErrorMessage(), Type((OperationType::type)0) {
  }

  virtual ~LinuxFileException() throw();
  std::string ErrorMessage;
  OperationType::type Type;
  std::map<std::string, std::string>  AdditionalInfo;

  _LinuxFileException__isset __isset;

  void __set_ErrorMessage(const std::string& val);

  void __set_Type(const OperationType::type val);

  void __set_AdditionalInfo(const std::map<std::string, std::string> & val);

  bool operator == (const LinuxFileException & rhs) const
  {
    if (!(ErrorMessage == rhs.ErrorMessage))
      return false;
    if (!(Type == rhs.Type))
      return false;
    if (__isset.AdditionalInfo != rhs.__isset.AdditionalInfo)
      return false;
    else if (__isset.AdditionalInfo && !(AdditionalInfo == rhs.AdditionalInfo))
      return false;
    return true;
  }
  bool operator != (const LinuxFileException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LinuxFileException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const LinuxFileException& obj);
};

void swap(LinuxFileException &a, LinuxFileException &b);

typedef struct _LinuxFileResponse__isset {
  _LinuxFileResponse__isset() : AdditionalInfo(false) {}
  bool AdditionalInfo :1;
} _LinuxFileResponse__isset;

class LinuxFileResponse {
 public:

  static const char* ascii_fingerprint; // = "EACFD21C18460944F3286BC9BC524B32";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0xCF,0xD2,0x1C,0x18,0x46,0x09,0x44,0xF3,0x28,0x6B,0xC9,0xBC,0x52,0x4B,0x32};

  LinuxFileResponse(const LinuxFileResponse&);
  LinuxFileResponse& operator=(const LinuxFileResponse&);
  LinuxFileResponse() : Success(0), ResponseMessage(), Type((OperationType::type)0) {
  }

  virtual ~LinuxFileResponse() throw();
  bool Success;
  std::string ResponseMessage;
  OperationType::type Type;
  std::map<std::string, std::string>  AdditionalInfo;

  _LinuxFileResponse__isset __isset;

  void __set_Success(const bool val);

  void __set_ResponseMessage(const std::string& val);

  void __set_Type(const OperationType::type val);

  void __set_AdditionalInfo(const std::map<std::string, std::string> & val);

  bool operator == (const LinuxFileResponse & rhs) const
  {
    if (!(Success == rhs.Success))
      return false;
    if (!(ResponseMessage == rhs.ResponseMessage))
      return false;
    if (!(Type == rhs.Type))
      return false;
    if (__isset.AdditionalInfo != rhs.__isset.AdditionalInfo)
      return false;
    else if (__isset.AdditionalInfo && !(AdditionalInfo == rhs.AdditionalInfo))
      return false;
    return true;
  }
  bool operator != (const LinuxFileResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LinuxFileResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const LinuxFileResponse& obj);
};

void swap(LinuxFileResponse &a, LinuxFileResponse &b);

typedef struct _GetFileLengthResponse__isset {
  _GetFileLengthResponse__isset() : ErrorMessage(false) {}
  bool ErrorMessage :1;
} _GetFileLengthResponse__isset;

class GetFileLengthResponse {
 public:

  static const char* ascii_fingerprint; // = "047A24EC93E49ED134CB8CA922D4BAFD";
  static const uint8_t binary_fingerprint[16]; // = {0x04,0x7A,0x24,0xEC,0x93,0xE4,0x9E,0xD1,0x34,0xCB,0x8C,0xA9,0x22,0xD4,0xBA,0xFD};

  GetFileLengthResponse(const GetFileLengthResponse&);
  GetFileLengthResponse& operator=(const GetFileLengthResponse&);
  GetFileLengthResponse() : FileLength(0), Success(0), ErrorMessage() {
  }

  virtual ~GetFileLengthResponse() throw();
  int64_t FileLength;
  bool Success;
  std::string ErrorMessage;

  _GetFileLengthResponse__isset __isset;

  void __set_FileLength(const int64_t val);

  void __set_Success(const bool val);

  void __set_ErrorMessage(const std::string& val);

  bool operator == (const GetFileLengthResponse & rhs) const
  {
    if (!(FileLength == rhs.FileLength))
      return false;
    if (!(Success == rhs.Success))
      return false;
    if (__isset.ErrorMessage != rhs.__isset.ErrorMessage)
      return false;
    else if (__isset.ErrorMessage && !(ErrorMessage == rhs.ErrorMessage))
      return false;
    return true;
  }
  bool operator != (const GetFileLengthResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetFileLengthResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const GetFileLengthResponse& obj);
};

void swap(GetFileLengthResponse &a, GetFileLengthResponse &b);

}}} // namespace

#endif
