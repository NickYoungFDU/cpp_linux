/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef cpp_linux_TYPES_H
#define cpp_linux_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace azure { namespace storage { namespace cpp_linux {

struct MatchInformation {
  enum type {
    OnlyOnServer = 1,
    OnlyInKeys = 2,
    DeletedOnClient = 3,
    Match = 4
  };
};

extern const std::map<int, const char*> _MatchInformation_VALUES_TO_NAMES;

struct LinuxFileMode {
  enum type {
    Append = 0,
    Create = 1,
    CreateNew = 2,
    Open = 3,
    OpenOrCreate = 4,
    Truncate = 5
  };
};

extern const std::map<int, const char*> _LinuxFileMode_VALUES_TO_NAMES;

struct LinuxFileAccess {
  enum type {
    Read = 0,
    Write = 1,
    ReadWrite = 2
  };
};

extern const std::map<int, const char*> _LinuxFileAccess_VALUES_TO_NAMES;

struct OperationType {
  enum type {
    MapFileShare = 0,
    UnmapFileShare = 1,
    CreateDirectory = 2,
    DeleteDirectory = 3,
    CreateFile = 4,
    DeleteFile = 5,
    ReadFile = 6,
    WriteFile = 7,
    ListFile = 8,
    GetFileLength = 9,
    SetFileLength = 10
  };
};

extern const std::map<int, const char*> _OperationType_VALUES_TO_NAMES;

class LinuxFileException;

class LinuxFileResponse;

typedef struct _LinuxFileException__isset {
  _LinuxFileException__isset() : AdditionalInfo(false) {}
  bool AdditionalInfo :1;
} _LinuxFileException__isset;

class LinuxFileException : public ::apache::thrift::TException {
 public:

  static const char* ascii_fingerprint; // = "BDDAF3D09FC0B99327A424F4DD1D4E7A";
  static const uint8_t binary_fingerprint[16]; // = {0xBD,0xDA,0xF3,0xD0,0x9F,0xC0,0xB9,0x93,0x27,0xA4,0x24,0xF4,0xDD,0x1D,0x4E,0x7A};

  LinuxFileException(const LinuxFileException&);
  LinuxFileException& operator=(const LinuxFileException&);
  LinuxFileException() : ErrorMessage(), Type((OperationType::type)0) {
  }

  virtual ~LinuxFileException() throw();
  std::string ErrorMessage;
  OperationType::type Type;
  std::map<std::string, std::string>  AdditionalInfo;

  _LinuxFileException__isset __isset;

  void __set_ErrorMessage(const std::string& val);

  void __set_Type(const OperationType::type val);

  void __set_AdditionalInfo(const std::map<std::string, std::string> & val);

  bool operator == (const LinuxFileException & rhs) const
  {
    if (!(ErrorMessage == rhs.ErrorMessage))
      return false;
    if (!(Type == rhs.Type))
      return false;
    if (__isset.AdditionalInfo != rhs.__isset.AdditionalInfo)
      return false;
    else if (__isset.AdditionalInfo && !(AdditionalInfo == rhs.AdditionalInfo))
      return false;
    return true;
  }
  bool operator != (const LinuxFileException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LinuxFileException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const LinuxFileException& obj);
};

void swap(LinuxFileException &a, LinuxFileException &b);

typedef struct _LinuxFileResponse__isset {
  _LinuxFileResponse__isset() : AdditionalInfo(false), Buffer(false), Directories(false), Files(false) {}
  bool AdditionalInfo :1;
  bool Buffer :1;
  bool Directories :1;
  bool Files :1;
} _LinuxFileResponse__isset;

class LinuxFileResponse {
 public:

  static const char* ascii_fingerprint; // = "111D3CD199039234A243F1498E751DCF";
  static const uint8_t binary_fingerprint[16]; // = {0x11,0x1D,0x3C,0xD1,0x99,0x03,0x92,0x34,0xA2,0x43,0xF1,0x49,0x8E,0x75,0x1D,0xCF};

  LinuxFileResponse(const LinuxFileResponse&);
  LinuxFileResponse& operator=(const LinuxFileResponse&);
  LinuxFileResponse() : Success(0), ResponseMessage(), Type((OperationType::type)0), Buffer() {
  }

  virtual ~LinuxFileResponse() throw();
  bool Success;
  std::string ResponseMessage;
  OperationType::type Type;
  std::map<std::string, std::string>  AdditionalInfo;
  std::string Buffer;
  std::map<std::string, MatchInformation::type>  Directories;
  std::map<std::string, MatchInformation::type>  Files;

  _LinuxFileResponse__isset __isset;

  void __set_Success(const bool val);

  void __set_ResponseMessage(const std::string& val);

  void __set_Type(const OperationType::type val);

  void __set_AdditionalInfo(const std::map<std::string, std::string> & val);

  void __set_Buffer(const std::string& val);

  void __set_Directories(const std::map<std::string, MatchInformation::type> & val);

  void __set_Files(const std::map<std::string, MatchInformation::type> & val);

  bool operator == (const LinuxFileResponse & rhs) const
  {
    if (!(Success == rhs.Success))
      return false;
    if (!(ResponseMessage == rhs.ResponseMessage))
      return false;
    if (!(Type == rhs.Type))
      return false;
    if (__isset.AdditionalInfo != rhs.__isset.AdditionalInfo)
      return false;
    else if (__isset.AdditionalInfo && !(AdditionalInfo == rhs.AdditionalInfo))
      return false;
    if (__isset.Buffer != rhs.__isset.Buffer)
      return false;
    else if (__isset.Buffer && !(Buffer == rhs.Buffer))
      return false;
    if (__isset.Directories != rhs.__isset.Directories)
      return false;
    else if (__isset.Directories && !(Directories == rhs.Directories))
      return false;
    if (__isset.Files != rhs.__isset.Files)
      return false;
    else if (__isset.Files && !(Files == rhs.Files))
      return false;
    return true;
  }
  bool operator != (const LinuxFileResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LinuxFileResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const LinuxFileResponse& obj);
};

void swap(LinuxFileResponse &a, LinuxFileResponse &b);

}}} // namespace

#endif
